# Babylon Architecture Decisions
# Key decisions and their rationale (ADR-style)

meta:
  version: "1.1.0"
  updated: "2025-12-07"
  format: "decision_id: {status, date, context, decision, rationale, consequences}"

# =============================================================================
# ARCHITECTURAL DECISIONS
# =============================================================================

decisions:

  ADR001_embedded_trinity:
    status: "accepted"
    date: "2024-12"
    title: "Three-layer local architecture (Ledger/Topology/Archive)"
    context: |
      Game needs to handle rigid state (economics), fluid state (relationships),
      and semantic memory (history/narrative) differently.
    decision: |
      Separate into three architectural layers:
      - Ledger: SQLite/Pydantic for material state
      - Topology: NetworkX for relational state
      - Archive: ChromaDB for semantic memory
    rationale:
      - "Each layer has different consistency/mutability requirements"
      - "Separation enables independent testing and evolution"
      - "Mirrors materialist distinction: base/relations/superstructure"
    consequences:
      positive:
        - "Clear separation of concerns"
        - "Can swap implementations per layer"
      negative:
        - "More complexity than single-store approach"
        - "Cross-layer queries require coordination"

  ADR002_sqlite_over_postgres:
    status: "accepted"
    date: "2024-12-07"
    title: "SQLite instead of PostgreSQL"
    context: |
      Initially configured PostgreSQL, but this is a local game
      with no multi-user requirements.
    decision: "Use SQLite for all persistent storage"
    rationale:
      - "No server to manage"
      - "Zero configuration"
      - "Portable game saves (single file)"
      - "Sufficient performance for single-player"
    consequences:
      positive:
        - "Simpler deployment"
        - "No external dependencies"
      negative:
        - "Can't easily add multiplayer later"
        - "No concurrent writes (not needed)"

  ADR003_ai_as_observer:
    status: "accepted"
    date: "2024-12"
    title: "AI generates narrative, never controls mechanics"
    context: |
      LLMs are non-deterministic. Game mechanics must be
      reproducible and testable.
    decision: |
      AI sits in Archive layer only. It can:
      - Query state and history
      - Generate narrative text
      It cannot:
      - Modify game state
      - Determine mechanical outcomes
    rationale:
      - "Deterministic mechanics enable testing"
      - "Reproducible gameplay"
      - "AI failures don't break game"
      - "Separation of narration from simulation"
    consequences:
      positive:
        - "Game works without AI"
        - "Testable mechanics"
      negative:
        - "Less emergent AI behavior"
        - "More explicit mechanics required"

  ADR004_json_over_xml:
    status: "accepted"
    date: "2024-12-07"
    title: "JSON for game data instead of XML"
    context: |
      Legacy data was in XML. Need machine-readable format
      that's easy to validate and work with.
    decision: "Migrate all game data to JSON with JSON Schema validation"
    rationale:
      - "Native Python support (json module)"
      - "JSON Schema provides validation"
      - "Easier to read/write programmatically"
      - "Better tooling ecosystem"
    consequences:
      positive:
        - "Schema validation catches errors early"
        - "Cleaner data structures"
      negative:
        - "Migration effort (completed)"
        - "XML kept as reference (minor storage cost)"

  ADR005_json_schema_2020:
    status: "accepted"
    date: "2024-12-07"
    title: "JSON Schema Draft 2020-12"
    context: |
      Need schema validation for game data. Multiple JSON Schema
      versions exist.
    decision: "Use Draft 2020-12, the latest stable version"
    rationale:
      - "Best $ref resolution"
      - "Dynamic references support"
      - "Active development"
      - "referencing library support"
    consequences:
      positive:
        - "Modern features available"
        - "Good library support"
      negative:
        - "Some older tools may not support"

  ADR006_pydantic_models:
    status: "accepted"
    date: "2024-12"
    title: "Pydantic for all game objects"
    context: |
      Need runtime validation and type safety for game entities.
    decision: "All game objects are Pydantic BaseModel subclasses"
    rationale:
      - "Runtime validation"
      - "Automatic serialization"
      - "IDE support"
      - "Clear schema definition"
    consequences:
      positive:
        - "Type safety"
        - "Self-documenting models"
      negative:
        - "Slight performance overhead"
        - "Learning curve"

  ADR007_data_driven_design:
    status: "accepted"
    date: "2024-12"
    title: "Game logic in data, not code"
    context: |
      Game has many entities with varying behaviors. Hardcoding
      each case leads to unmaintainable code.
    decision: |
      Define game rules in data files (JSON/TOML).
      Code provides engine, data provides content.
    rationale:
      - "Easy content modification"
      - "Modding support"
      - "Clear separation of concerns"
      - "Non-programmers can adjust balance"
    consequences:
      positive:
        - "Flexible content"
        - "Moddable"
      negative:
        - "More complex data structures"
        - "Data validation critical"

  ADR008_test_separation:
    status: "accepted"
    date: "2024-12"
    title: "Separate fast tests from AI tests"
    context: |
      AI tests are slow and non-deterministic.
      Logic tests should be fast and reliable.
    decision: |
      Use pytest markers to separate:
      - math, ledger, topology: fast, deterministic
      - ai: slow, can be flaky
    rationale:
      - "Fast feedback loop for logic changes"
      - "CI can run fast tests on every commit"
      - "AI tests run less frequently"
    consequences:
      positive:
        - "Fast TDD cycle"
        - "Clear test categories"
      negative:
        - "Must remember to run both"

  ADR009_networkx_topology:
    status: "accepted"
    date: "2024-12-07"
    title: "NetworkX for Topology layer graph storage"
    context: |
      The Embedded Trinity architecture (ADR001) specifies a Topology layer for
      fluid relational state: class solidarity networks, dialectical relationships,
      supply chains, tension flows. This requires a graph data structure.

      Options evaluated:
      - NetworkX: Pure Python, rich algorithms, in-memory
      - igraph: C-based, faster, less Pythonic API
      - graph-tool: C++ core, fastest, complex installation
      - Neo4j: Full graph DB, requires external server
      - SQLite edge tables: DIY graph, no built-in algorithms
      - RDFLib: Semantic web focus, overkill for game state
    decision: |
      Use NetworkX as the graph engine for the Topology layer.
      Graph state persists to SQLite (Ledger) for save/load.
      At startup, build NetworkX graph from SQLite edge data.
      During gameplay, mutate graph in-memory.
      On save, serialize graph back to SQLite.
    rationale:
      - "Pure Python: no external servers, matches 'no external dependencies' principle"
      - "Rich algorithm library: centrality, paths, community detection built-in"
      - "Sufficient performance: game will have ~1000-10000 nodes max, not millions"
      - "Pythonic API: easy to test, integrates well with Pydantic models"
      - "Serializable: nx.node_link_data() exports to JSON for SQLite storage"
      - "Phase 1 scope: 2 nodes, 1 edge - any graph library works, pick simplest"
      - "TDD-friendly: graph operations are pure functions, easy to unit test"
    alternatives_rejected:
      igraph:
        reason: "C dependency complicates installation; performance gain unnecessary at our scale"
      graph_tool:
        reason: "Difficult to install (needs C++ compilation); overkill for game-sized graphs"
      neo4j:
        reason: "Violates 'no external servers' principle; adds operational complexity"
      sqlite_edges:
        reason: "Would require implementing graph algorithms from scratch; NetworkX provides them"
    consequences:
      positive:
        - "Zero external dependencies beyond Python package"
        - "Rich built-in algorithms for atomization metrics, hub detection, path analysis"
        - "Easy serialization to SQLite for game saves"
        - "Well-documented, mature library with active maintenance"
        - "Trivial to test graph logic in isolation"
      negative:
        - "Pure Python slower than C-based alternatives (acceptable at our scale)"
        - "In-memory only: requires explicit save/load logic to persist state"
        - "No concurrent write safety (not needed for single-player turn-based game)"
    performance_notes: |
      NetworkX handles 10,000+ nodes efficiently for in-memory operations.
      Phase 4 projection: 17 entity types × ~100 instances = ~1,700 nodes.
      This is well within NetworkX's comfortable range.
      If future requirements exceed 100,000 nodes, reconsider igraph migration.
    integration_pattern: |
      SQLite (Ledger)         NetworkX (Topology)        ChromaDB (Archive)
        ┌──────────┐           ┌───────────────┐           ┌──────────┐
        │ entities │──startup──▶│ G = nx.DiGraph│◀──query───│ semantic │
        │ edges    │           │ nodes + edges │           │ embeddings│
        └──────────┘           └───────────────┘           └──────────┘
             ▲                        │
             │                        │
             └───────save game────────┘

  ADR011_pure_graph_architecture:
    status: "accepted"
    date: "2024-12-07"
    title: "Pure Graph Architecture: Graph + Math = History"
    context: |
      Following ADR010 (bypass Economy/Politics), a deeper architectural review
      was conducted with multi-AI consensus (Claude + Gemini + User).

      Key insight from Gemini:
      "The previous architecture was trying to simulate INSTITUTIONS.
       The new architecture simulates MATERIAL RELATIONS.
       This is the shift from Liberalism to Materialism."

      The Economy class modeled "the economy" as a liberal abstraction.
      In MLM-TW, "the economy" doesn't exist as a thing - it's the name we give
      to the totality of production relations. The graph makes this explicit.

    decisions:
      delete_legacy_classes:
        action: "Delete Economy and Politics classes immediately"
        rationale: |
          - Not "preserve for future" - that's hoarding technical debt
          - If patterns needed later, write fresh with correct architecture
          - git log is the museum for old code
        files_to_delete:
          - "src/babylon/core/economy.py"
          - "src/babylon/core/politics.py"

      pure_graph_option_c:
        action: "Everything is nodes and edges (Option C)"
        rationale: |
          - Geography is just another relation type
          - Hierarchy exists as CONTAINS edges, doesn't constrain other edges
          - A neighborhood in Global South can have direct edge to hedge fund in NYC
          - Imperialism doesn't respect administrative boundaries - neither should our graph
        edge_types:
          - "CONTAINS (geographic hierarchy)"
          - "EXTRACTS_FROM (economic exploitation)"
          - "REPRESSES (political violence)"
          - "PRODUCES (labor value)"
          - "ORGANIZES (class solidarity)"
        example: |
          USA --[CONTAINS]--> Kansas_City
          Proletariat_KC --[EXTRACTS_FROM]--> Bourgeoisie_NY
          Police_KC --[REPRESSES]--> Proletariat_KC

      hybrid_state_management:
        action: "Snapshots for Engine, Events for Archive"
        rationale: |
          - Engine needs current state to calculate next state (Snapshots)
          - AI narrative needs history of what happened (Events)
          - Math and Story have different data needs - don't confuse them
          - Testing is cleaner: Engine tests are pure functions on snapshots
        structure:
          engine: "Immutable WorldState snapshots"
          archive: "Event log for narrative generation"

      networkx_from_day_one:
        action: "Use NetworkX immediately, not deferred"
        rationale: |
          - If concept is "everything is a graph," implementation should be a graph
          - Using dict for 2 nodes then switching later is chosen technical debt
          - NetworkX is lightweight - no cost for small graphs
          - Built-in algorithms available when needed (centrality, paths)
          - Keeps implementation honest to architecture
        revision: "Supersedes ADR010 recommendation to defer NetworkX"

      simulation_config_is_core:
        action: "SimulationConfig is part of irreducible kernel"
        rationale: |
          - Formulas are parameterized (α, λ, S, k)
          - Without coefficients, formulas are abstract math, not simulation
          - Config is as essential as State and Engine

    the_true_kernel:
      description: "The irreducible core of the simulation"
      components:
        world_state:
          purpose: "The Data"
          contains:
            - "Graph (Nodes: entities)"
            - "Graph (Edges: relations)"
            - "tick: current turn"

        simulation_config:
          purpose: "The Constants"
          contains:
            - "α (extraction_efficiency)"
            - "λ (loss_aversion = 2.25)"
            - "S (subsistence_threshold)"
            - "k (consciousness_sensitivity)"
            - "repression_level"

        formula_library:
          purpose: "The Laws"
          pattern: "f(data, config) → value"
          location: "babylon.systems.formulas"

        simulation_engine:
          purpose: "The Time"
          pattern: "step(state, config) → new_state"

      equation: "Graph + Math = History"

    philosophical_grounding:
      insight: |
        "The Economy is not a class; it is the sum of all EXTRACTS_FROM edges."
        "Politics is not a class; it is the sum of all REPRESSES edges."

        In materialist analysis, abstractions like "the economy" or "politics"
        don't exist as things. They are names for the totality of material relations.
        The graph architecture makes this explicit:
        - No Economy node exists
        - Only relations of extraction, production, exchange
        - "The economy" is a QUERY over those edges, not an entity

      alignment: "Architecture encodes theory. The code IS the analysis."

    consequences:
      positive:
        - "Code matches MLM-TW theoretical framework"
        - "No liberal abstractions hiding material relations"
        - "Flexible: any node can relate to any other node"
        - "Queryable: 'total extraction' is sum of EXTRACTS_FROM edges"
        - "Testable: graph operations are well-understood"
        - "Scalable: NetworkX handles large graphs efficiently"
      negative:
        - "Requires deleting existing code (minimal loss)"
        - "Slightly more abstract than class-based approach"
        - "Team must understand graph thinking"

    consensus:
      participants:
        - "Claude (Opus 4.5)"
        - "Gemini (via user)"
        - "User (Persephone)"
      mantra: "Graph + Math = History"
      supersedes:
        - "ADR010 NetworkX deferral recommendation"

  ADR010_direct_formula_architecture:
    status: "accepted"
    date: "2024-12-07"
    title: "Direct Entities + Formulas architecture (bypass Economy/Politics classes)"
    context: |
      During Phase 2 design review, discovered THREE disconnected math systems:

      1. formulas.py (349 lines, 40 tests)
         - MLM-TW formulas: imperial rent, survival calculus, consciousness drift
         - Pure functions, theoretically grounded, TESTED

      2. Economy class (core/economy.py, 148 lines, 0 tests)
         - Generic economic simulation with its own internal formulas
         - Has update() method but doesn't use formulas.py
         - UNTESTED

      3. Politics class (core/politics.py, 164 lines, 0 tests)
         - Generic political simulation with its own internal formulas
         - Has update() method but doesn't use formulas.py
         - UNTESTED

      4. ContradictionAnalysis (systems/contradiction_analysis.py, 20 tests)
         - Tension tracking and phase transitions
         - Works well but doesn't call formulas.py either

      These systems are completely disconnected. Economy._update_class_relations()
      uses generic formulas, not the MLM-TW formulas we carefully designed and tested.

      Options evaluated:
      A. Replace Economy/Politics entirely with new subsystems
      B. Refactor Economy/Politics to use formulas.py internally
      C. Direct Entities + Formulas (no subsystems)
    decision: |
      Option C: Direct Entities + Formulas architecture for Phase 2.

      SimulationEngine.step() calls formulas directly on entities:

      1. For each Relationship:
         - Call calculate_imperial_rent()
         - Update entity wealth

      2. For each SocialClass:
         - Call calculate_consciousness_drift()
         - Call calculate_acquiescence_probability()
         - Call calculate_revolution_probability()
         - Update entity state

      3. For each Contradiction:
         - Update tension based on entity states
         - Check for rupture/synthesis via ContradictionAnalysis

      No Economy class. No Politics class in the game loop.
      Just: Entities (data) + Formulas (math) + Engine (orchestration)
    rationale:
      - "Simplest possible architecture for 2-node Phase 2"
      - "formulas.py has 40 tests; Economy/Politics have 0 tests"
      - "Avoids two layers of abstraction"
      - "MLM-TW formulas ARE the theory; generic subsystems obscure it"
      - "Single source of truth for calculations"
      - "Easier to trace: entity field -> formula -> new value"
      - "YAGNI: Economy/Politics may be useful later, but not needed now"
    alternatives_rejected:
      replace_economy_politics:
        reason: "Throws away existing code; may be useful for future complexity"
      refactor_to_use_formulas:
        reason: "Adds abstraction layer without benefit for 2-node simulation"
    consequences:
      positive:
        - "Direct traceability from entity to formula to result"
        - "No untested code in critical path"
        - "Simpler debugging: fewer layers"
        - "Engine logic matches theoretical documentation"
      negative:
        - "Economy/Politics classes deleted (see ADR011)"
        - "May need to introduce subsystems when scaling to many entities"
        - "Engine.step() may grow complex (mitigate with clear sections)"
    related_gap_analysis:
      gap_1: "Entity-to-Aggregate: Aggregates computed from entities, not stored"
      gap_2: "Formula-to-Entity wiring: Explicit mapping required (see game-loop-architecture.yaml)"
      gap_3: "This decision resolves the disconnected systems gap"
      gap_4: "Initialization: Factory function for test scenarios"
      gap_5: "Phase transitions: ContradictionAnalysis handles rupture/synthesis"
      gap_6: "Coefficients: SimulationConfig object holds global constants"
      gap_7: "NetworkX: Used from day one per ADR011 (supersedes original ADR010 recommendation)"
      gap_8: "Testing: Property-based tests for feedback loop verification"
    future_considerations: |
      When scaling beyond Phase 2 (many entities, multiple countries),
      may introduce subsystem layer for:
      - Aggregate calculations (GDP computed from all entities)
      - Batch updates (process all entities of a type together)
      - Performance optimization (cache intermediate results)

      Note: Economy/Politics classes were DELETED per ADR011.
      If subsystems are needed in future, write fresh with correct architecture.
      git log preserves the old code for reference if needed.

    implementation_status: |
      IMPLEMENTED in Phase 2 with 330 tests proving:
      - Direct formula wiring works
      - Feedback loops produce emergent behavior
      - No subsystem layer needed for 2-node simulation

# =============================================================================
# PENDING DECISIONS
# =============================================================================

pending:

  PDR001_ui_framework:
    status: "pending"
    options:
      - "NiceGUI (Python-native)"
      - "Obsidian-like custom renderer"
      - "Terminal-only (Rich)"
    leaning: "NiceGUI for game, Obsidian-like for wiki"
    blockers: "Game loop needs to exist first"

  PDR002_wiki_implementation:
    status: "brainstorm"
    reference: "brainstorm/gramscian-wiki-engine.md"
    options:
      - "Jinja templates + Markdown + Obsidian"
      - "Structured JSON + custom renderer"
    considerations:
      - "Hegemony mechanic integration"
      - "Factional control model"
      - "Player interaction model"

# =============================================================================
# REJECTED DECISIONS
# =============================================================================

rejected:

  RDR001_postgres:
    date: "2024-12-07"
    proposal: "Use PostgreSQL for persistence"
    rejection_reason: "Overkill for local single-player game"
    replaced_by: "ADR002_sqlite_over_postgres"

  RDR002_toml_data:
    date: "2024-12-07"
    proposal: "Use TOML for game data"
    rejection_reason: |
      JSON has better schema validation ecosystem.
      TOML better for config, JSON better for data.
    note: "TOML may still be used for configuration files"
