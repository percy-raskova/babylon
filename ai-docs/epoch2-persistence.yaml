# Epoch 2 Persistence Specification
# Strategic Map: KuzuDB + Tactical Cache: NetworkX
# Date: 2025-12-26
# Related: ADR029_hybrid_graph_architecture

meta:
  version: "1.1.0"
  status: "specification"
  epoch: 2
  codename: "The War"
  purpose: "Define the hybrid graph architecture for continental-scale simulation"
  amendments:
    - version: "1.1.0"
      date: "2025-12-26"
      title: "Dynamic Sovereignty Refactor"
      summary: "Sovereignty as Node, not Property. Enables O(1) border changes for civil war and Balkanization."

# =============================================================================
# OVERVIEW
# =============================================================================

overview:
  thesis: |
    Epoch 2 models the full United States as a battleground. This requires ~74,000
    Territory nodes (50 states + 3,000 counties + 70,000 cities/townships) with
    both administrative hierarchy (who governs what) and physical adjacency
    (what borders what).

    Pure NetworkX cannot handle this scale in RAM. We bifurcate the architecture:
    - **KuzuDB**: Disk-backed "Strategic Map" storing the complete world
    - **NetworkX**: In-memory "Tactical Cache" for active simulation sectors

  key_concepts:
    strategic_map:
      storage: "KuzuDB (embedded graph database)"
      contains: "Complete World Graph + Historical Chronicle"
      scale: "74,000+ nodes, disk-backed"
      queries: "Cypher-like syntax for complex graph traversal"

    tactical_cache:
      storage: "NetworkX (in-memory)"
      contains: "Active Sector (subset being simulated)"
      scale: "100-1,000 nodes per sector"
      purpose: "Fast tick calculations, unchanged from Epoch 1"

    hydration:
      definition: "Loading nodes from Strategic Map into Tactical Cache"
      trigger: "Player action, conflict expansion, or sector boundary crossing"

    flush:
      definition: "Writing Tactical Cache changes back to Strategic Map"
      trigger: "End of tick, checkpoint, or sector transition"

    # === Dynamic Sovereignty (v1.1.0) ===
    dynamic_sovereignty:
      definition: "Sovereignty as graph edges, not node properties"
      principle: |
        The Land (physical mesh) and the State (sovereignty claims) are independent layers.
        A mountain range doesn't care who claims sovereignty over it.
      layers:
        land_layer:
          edges: "ADJACENT_TO"
          nature: "Immutable geography - physical borders, terrain"
          changes: "Only via geological/construction events (rare)"
        state_layer:
          edges: "CLAIMS (Sovereign → Territory)"
          nature: "Mutable politics - who governs what"
          changes: "O(1) edge rewiring for secession, conquest, revolution"

    sovereign:
      definition: "A political entity capable of claiming sovereignty over Territory"
      examples:
        - "United States Federal Government"
        - "Provisional Revolutionary Command"
        - "California Republic (post-secession)"
        - "Occupied Zone Administration"

    fracture_operation:
      definition: "Sovereignty transfer via edge manipulation"
      steps:
        - "Delete or reduce control_level on old Sovereign→Territory CLAIMS edge"
        - "Create new CLAIMS edge from new Sovereign to Territory"
      complexity: "O(1) - pure graph rewiring, no node property changes"

# =============================================================================
# NODE SCHEMAS
# =============================================================================

node_schemas:

  # ===========================================================================
  # SOVEREIGN (v1.1.0 - Dynamic Sovereignty)
  # ===========================================================================

  Sovereign:
    description: |
      A political entity capable of claiming sovereignty over Territory. Sovereigns are
      first-class nodes, not properties, enabling:
      - Multiple competing sovereignty claims (civil war, dual power)
      - O(1) border changes via edge rewiring (secession, conquest)
      - Legitimacy tracking over time (recognition, consent)

      Examples:
      - United States Federal Government (recognized state)
      - Provisional Revolutionary Command (insurgent)
      - California Republic (secessionist)
      - FEMA Zone 9 Administration (emergency authority)

    properties:
      id:
        type: "STRING"
        description: "Unique identifier for the sovereign entity"
        format: "SOV_{CODE} (e.g., 'SOV_USA_FED', 'SOV_PRC', 'SOV_CAL_REP')"
        primary_key: true
        examples:
          - "SOV_USA_FED"  # United States Federal Government
          - "SOV_PRC"      # Provisional Revolutionary Command
          - "SOV_CAL_REP"  # California Republic
          - "SOV_FEMA_9"   # FEMA Zone 9 Administration

      name:
        type: "STRING"
        description: "Human-readable name of the sovereign"
        examples:
          - "United States Federal Government"
          - "Provisional Revolutionary Command"
          - "California Republic"

      sovereignty_type:
        type: "ENUM"
        values:
          - "RECOGNIZED_STATE"  # Internationally recognized nation-state
          - "PROVISIONAL"       # Transitional/revolutionary government
          - "INSURGENT"         # Armed revolutionary movement
          - "OCCUPATION"        # Military occupation authority
          - "SECESSIONIST"      # Breakaway state seeking recognition
          - "EMERGENCY"         # Emergency/martial law authority
        description: "Classification of sovereignty claim"
        default: "RECOGNIZED_STATE"

      legitimacy:
        type: "DOUBLE"
        description: "Degree of recognized legitimate authority (0-1)"
        constraints: "[0.0, 1.0]"
        semantics:
          1.0: "Full international recognition + internal consent"
          0.7: "Recognized by major powers, some internal dissent"
          0.4: "Disputed recognition, significant resistance"
          0.1: "Widely rejected, controls only by force"
        default: 1.0
        note: "Affects diplomatic options, population compliance, AI faction behavior"

      color_hex:
        type: "STRING"
        description: "UI display color for this sovereign's territories"
        format: "#RRGGBB"
        examples:
          - "#3C3B6E"  # USA blue
          - "#B22234"  # Revolutionary red
          - "#FFD700"  # California gold
        default: "#808080"

      capital_territory_id:
        type: "STRING"
        description: "Territory ID of the sovereign's capital/seat of power"
        nullable: true
        foreign_key: "Territory.id"

      founded_tick:
        type: "INT32"
        description: "Simulation tick when this sovereign was established"
        default: 0

      dissolved_tick:
        type: "INT32"
        description: "Simulation tick when this sovereign ceased to exist (null if active)"
        nullable: true
        default: null

    indexes:
      - property: "id"
        type: "PRIMARY"
      - property: "sovereignty_type"
        type: "HASH"
        reason: "Fast filtering by type (insurgent vs recognized)"
      - property: "legitimacy"
        type: "BTREE"
        reason: "Range queries for legitimacy thresholds"

  # ===========================================================================
  # TERRITORY
  # ===========================================================================

  Territory:
    description: |
      The fundamental spatial unit of Epoch 2. Represents either:
      - OGV (Observable Geographic Volume): Physical land (a county, a city block)
      - OPC (Observable Political Container): Administrative unit (a state, a jurisdiction)

      Note: OGV and OPC often overlap but can diverge (e.g., tribal lands within state
      boundaries, military bases with federal jurisdiction).

    properties:
      # === Identity ===
      id:
        type: "STRING"
        description: "Unique identifier using FIPS-like coding"
        format: "COUNTRY-STATE-COUNTY-LOCALITY (e.g., 'US-CA-037' for Los Angeles County)"
        primary_key: true
        examples:
          - "US"  # Federal level
          - "US-CA"  # California state
          - "US-CA-037"  # Los Angeles County
          - "US-CA-037-LA"  # City of Los Angeles

      name:
        type: "STRING"
        description: "Human-readable name"
        examples: ["United States", "California", "Los Angeles County", "Compton"]

      type:
        type: "ENUM"
        values: ["OGV", "OPC"]
        description: |
          OGV = Observable Geographic Volume (physical land)
          OPC = Observable Political Container (administrative unit)
        default: "OPC"

      # === Material Properties ===
      area_sq_km:
        type: "DOUBLE"
        description: "Physical area in square kilometers"
        constraints: ">= 0"
        note: "OPC without physical territory (e.g., virtual jurisdictions) may have 0"

      bioregion:
        type: "STRING"
        description: "Ecological classification for metabolism calculations"
        examples: ["Pacific Coast", "Great Basin", "Gulf Coast", "Great Plains"]
        note: "Maps to regeneration rates in MetabolismSystem"

      habitability:
        type: "DOUBLE"
        description: "How suitable for human settlement (0-1)"
        constraints: "[0.0, 1.0]"
        factors: "Climate, water access, soil quality, infrastructure"
        default: 0.5

      # === Political Properties ===
      # NOTE (v1.1.0): The `controller` property has been REMOVED.
      # Sovereignty is now expressed via CLAIMS edges from Sovereign nodes.
      # - STATE → Sovereign node with sovereignty_type=RECOGNIZED_STATE
      # - PLAYER → Player's Sovereign node (sovereignty_type=INSURGENT/PROVISIONAL)
      # - CONTESTED → Multiple CLAIMS edges with different control_levels
      # - NEUTRAL → No CLAIMS edges (ungoverned territory)

      heat:
        type: "DOUBLE"
        description: "State attention level from TerritorySystem"
        constraints: "[0.0, 1.0]"
        note: "Heat >= 0.8 triggers eviction pipeline"
        default: 0.0

      # === Demographic Properties (Epoch 2A) ===
      population:
        type: "INT64"
        description: "Total population count"
        constraints: ">= 0"
        default: 0

      class_composition:
        type: "MAP"
        description: "Population breakdown by social class"
        schema:
          proletariat: "INT64"
          petty_bourgeoisie: "INT64"
          bourgeoisie: "INT64"
          lumpen: "INT64"
        note: "Sum should equal population"

      # === Chronicle Properties (historical tracking) ===
      created_tick:
        type: "INT32"
        description: "Tick when this territory was created/discovered"
        default: 0

      last_modified_tick:
        type: "INT32"
        description: "Tick when this territory was last modified"
        default: 0

    indexes:
      - property: "id"
        type: "PRIMARY"
      # NOTE (v1.1.0): controller index removed - use CLAIMS edges instead
      - property: "bioregion"
        type: "HASH"
        reason: "Fast filtering for metabolism calculations"
      - property: "heat"
        type: "BTREE"
        reason: "Range queries for state attention thresholds"

# =============================================================================
# EDGE SCHEMAS
# =============================================================================

edge_schemas:

  ADMINISTERS:
    description: |
      Represents administrative/political hierarchy. Forms a DAG (Directed Acyclic Graph)
      from Federal → State → County → City/Township.

      Direction: Parent → Child (the parent ADMINISTERS the child)

      Examples:
      - (US) -[:ADMINISTERS]-> (US-CA)  # Federal administers California
      - (US-CA) -[:ADMINISTERS]-> (US-CA-037)  # California administers LA County
      - (US-CA-037) -[:ADMINISTERS]-> (US-CA-037-LA)  # LA County administers LA City

    from_node: "Territory"
    to_node: "Territory"

    properties:
      control_level:
        type: "DOUBLE"
        description: "Degree of administrative control (0-1)"
        constraints: "[0.0, 1.0]"
        semantics:
          1.0: "Full de jure and de facto control"
          0.7: "De jure control, limited enforcement"
          0.3: "Nominal authority, mostly autonomous"
          0.0: "No effective control"
        default: 1.0

      legal_status:
        type: "ENUM"
        values:
          - "DE_JURE"      # Recognized legal authority
          - "DE_FACTO"     # Actual control without legal recognition
          - "CONTESTED"    # Multiple claimants
          - "SUBVERSIVE"   # Player has infiltrated but State has legal control
        description: |
          DE_JURE: The controlling entity has recognized legal authority
          DE_FACTO: Control exists but lacks formal recognition
          CONTESTED: Multiple factions claim authority
          SUBVERSIVE: Hidden player control (dual power situation)
        default: "DE_JURE"

    constraints:
      - name: "no_cycles"
        description: "ADMINISTERS must form a DAG (no territory administers itself)"
        enforcement: "Application-level validation"

      - name: "single_parent"
        description: "Each territory has at most one administrative parent"
        enforcement: "UNIQUE constraint on (to_node, edge_type)"
        note: "Exception: contested territories may have multiple claimants"

  ADJACENT_TO:
    description: |
      Represents physical adjacency (shared border). Forms a mesh/network graph.
      This is the "Land as Material" topology - who can move where, who borders whom.

      Direction: Bidirectional (if A borders B, B borders A)
      Implementation: Store both directions explicitly for query efficiency

      Examples:
      - (US-CA) -[:ADJACENT_TO]-> (US-NV)  # California borders Nevada
      - (US-CA) -[:ADJACENT_TO]-> (US-OR)  # California borders Oregon
      - (US-CA) -[:ADJACENT_TO]-> (US-AZ)  # California borders Arizona

    from_node: "Territory"
    to_node: "Territory"

    properties:
      barrier_type:
        type: "ENUM"
        values:
          - "NONE"       # Open border, easy movement
          - "RIVER"      # River/water barrier
          - "MOUNTAIN"   # Mountain range
          - "HIGHWAY"    # Highway corridor (increases permeability)
          - "BORDER"     # International border (special restrictions)
          - "WALL"       # Physical barrier (e.g., border wall)
        description: "Type of physical feature at the boundary"
        default: "NONE"

      permeability:
        type: "DOUBLE"
        description: "Ease of movement/influence across boundary (0-1)"
        constraints: "[0.0, 1.0]"
        semantics:
          1.0: "Completely open, no friction"
          0.7: "Minor barriers (river, mountains)"
          0.3: "Significant barriers (controlled border)"
          0.0: "Impassable (fortified wall, ocean)"
        default: 1.0

      border_length_km:
        type: "DOUBLE"
        description: "Length of shared border in kilometers"
        constraints: ">= 0"
        default: 0.0
        note: "Used for calculating influence spread and military operations"

    constraints:
      - name: "bidirectional"
        description: "If A-[:ADJACENT_TO]->B exists, B-[:ADJACENT_TO]->A must exist"
        enforcement: "Application-level validation on insert"

      - name: "no_self_loops"
        description: "Territory cannot be adjacent to itself"
        enforcement: "CHECK constraint"

  # ===========================================================================
  # CLAIMS (v1.1.0 - Dynamic Sovereignty)
  # ===========================================================================

  CLAIMS:
    description: |
      Represents a sovereignty claim from a Sovereign to a Territory. This is the
      core of the Dynamic Sovereignty system.

      Key Properties:
      - A Territory can have MULTIPLE CLAIMS edges (contested territory)
      - Only ONE claim should have control_level >= 0.5 at a time (effective control)
      - Sovereignty changes are O(1) edge operations (delete old, create new)

      Examples:
      - (SOV_USA_FED) -[:CLAIMS]-> (US-CA)  # USA claims California
      - (SOV_PRC) -[:CLAIMS]-> (US-CA-037)  # Revolutionary Command claims LA County
      - Dual power: Both edges exist with different control_levels

      Fracture Operation (Secession):
      ```cypher
      // Step 1: Reduce USA control over California
      MATCH (usa:Sovereign {id: 'SOV_USA_FED'})-[c:CLAIMS]->(ca:Territory {id: 'US-CA'})
      SET c.control_level = 0.1, c.legal_status = 'DISPUTED'

      // Step 2: Create California Republic claim
      MATCH (cal:Sovereign {id: 'SOV_CAL_REP'})
      MATCH (ca:Territory {id: 'US-CA'})
      CREATE (cal)-[:CLAIMS {control_level: 0.9, legal_status: 'DE_FACTO'}]->(ca)
      ```

    from_node: "Sovereign"
    to_node: "Territory"

    properties:
      control_level:
        type: "DOUBLE"
        description: "Degree of effective control (0-1)"
        constraints: "[0.0, 1.0]"
        semantics:
          1.0: "Complete control - all state functions operational"
          0.7: "Strong control - occasional resistance, functions mostly intact"
          0.4: "Contested - significant resistance, partial state collapse"
          0.1: "Nominal - claim exists but little actual control"
          0.0: "No control - claim is purely symbolic/historical"
        default: 1.0
        note: "Sum of control_levels for a territory should not exceed 1.0"

      fiscal_status:
        type: "ENUM"
        values:
          - "TAXED"     # Normal revenue extraction
          - "REVOLT"    # Tax resistance, reduced revenue
          - "BLOCKADE"  # External forces preventing revenue
          - "LIBERATED" # No taxation (revolutionary zone)
          - "OCCUPIED"  # Extraction by military force
        description: "Revenue relationship between sovereign and territory"
        default: "TAXED"

      legal_status:
        type: "ENUM"
        values:
          - "DE_JURE"   # Internationally recognized claim
          - "DE_FACTO"  # Actual control without recognition
          - "DISPUTED"  # Multiple claimants, no clear winner
          - "OCCUPIED"  # Military occupation, original sovereignty suspended
          - "CEDED"     # Formerly held, formally transferred
        description: "Legal nature of the sovereignty claim"
        default: "DE_JURE"

      claimed_since_tick:
        type: "INT32"
        description: "Tick when this claim was established"
        default: 0

      recognition_level:
        type: "DOUBLE"
        description: "International recognition of this specific claim (0-1)"
        constraints: "[0.0, 1.0]"
        default: 1.0
        note: "Affects diplomatic relations and legitimacy calculations"

    constraints:
      - name: "no_self_claim"
        description: "A sovereign cannot claim a territory that IS itself"
        enforcement: "Application-level validation"
        note: "Sovereigns are not territories"

      - name: "control_sum_limit"
        description: "Sum of control_levels for a territory should not exceed 1.0"
        enforcement: "Application-level validation"
        note: "Soft constraint - temporary violations during transitions allowed"

    indexes:
      - properties: ["from_node", "to_node"]
        type: "COMPOSITE"
        reason: "Fast lookup of claims by sovereign or territory"

# =============================================================================
# THE CHRONICLE: HISTORICAL TRACKING
# =============================================================================

chronicle:
  description: |
    The Chronicle stores historical snapshots enabling time-travel queries.
    "What was California's controller in tick 50?" becomes a simple query.

  tables:

    TerritorySnapshot:
      description: "Point-in-time snapshot of Territory state"
      properties:
        snapshot_id:
          type: "INT64"
          primary_key: true
          auto_increment: true
        territory_id:
          type: "STRING"
          foreign_key: "Territory.id"
        tick:
          type: "INT32"
          description: "Simulation tick when snapshot was taken"
        controller:
          type: "STRING"
        heat:
          type: "DOUBLE"
        population:
          type: "INT64"
        class_composition:
          type: "MAP"
      indexes:
        - properties: ["territory_id", "tick"]
          type: "COMPOSITE"
          reason: "Fast lookup of territory state at specific tick"

    EdgeSnapshot:
      description: "Point-in-time snapshot of edge state"
      properties:
        snapshot_id:
          type: "INT64"
          primary_key: true
          auto_increment: true
        edge_type:
          type: "STRING"
          values: ["ADMINISTERS", "ADJACENT_TO", "CLAIMS"]
        from_id:
          type: "STRING"
        to_id:
          type: "STRING"
        tick:
          type: "INT32"
        properties:
          type: "MAP"
          description: "Serialized edge properties at this tick"
      indexes:
        - properties: ["from_id", "to_id", "tick"]
          type: "COMPOSITE"

    SimulationEvent:
      description: "Log of significant events for narrative reconstruction"
      properties:
        event_id:
          type: "INT64"
          primary_key: true
          auto_increment: true
        tick:
          type: "INT32"
        event_type:
          type: "STRING"
          description: "EventType enum value"
        territory_id:
          type: "STRING"
          nullable: true
        payload:
          type: "MAP"
          description: "Event-specific data"
        created_at:
          type: "TIMESTAMP"
          default: "CURRENT_TIMESTAMP"

  query_examples:
    territory_at_tick: |
      // What was California's state in tick 50?
      MATCH (t:TerritorySnapshot)
      WHERE t.territory_id = 'US-CA' AND t.tick <= 50
      RETURN t
      ORDER BY t.tick DESC
      LIMIT 1

    controller_timeline: |
      // Timeline of who controlled Los Angeles
      MATCH (t:TerritorySnapshot)
      WHERE t.territory_id = 'US-CA-037-LA'
      RETURN t.tick, t.controller
      ORDER BY t.tick ASC

    front_line_at_tick: |
      // What territories were contested in tick 100?
      MATCH (t:TerritorySnapshot)
      WHERE t.tick = 100 AND t.controller = 'CONTESTED'
      RETURN t.territory_id, t.heat

# =============================================================================
# HYDRATION STRATEGY
# =============================================================================

hydration:
  description: |
    Hydration is the process of loading a "Sector" from KuzuDB into NetworkX
    for active simulation. The Tactical Cache holds only the nodes being
    actively simulated this tick.

  sector_selection:
    description: "How to determine which territories to hydrate"

    strategies:
      conflict_zone:
        description: "N-hop neighborhood around contested territories"
        query: |
          // Get all territories within 2 hops of contested zones
          MATCH (contested:Territory {controller: 'CONTESTED'})
          MATCH (t:Territory)
          WHERE t = contested
             OR EXISTS((t)-[:ADJACENT_TO*1..2]-(contested))
          RETURN t
        parameters:
          hop_distance: 2
          max_nodes: 500

      player_focus:
        description: "Territories where player has operations"
        query: |
          // Get player-controlled territories and neighbors
          MATCH (player:Territory {controller: 'PLAYER'})
          OPTIONAL MATCH (player)-[:ADJACENT_TO]-(neighbor)
          OPTIONAL MATCH (player)<-[:ADMINISTERS*1..2]-(parent)
          RETURN DISTINCT player, neighbor, parent

      hot_zones:
        description: "High-heat territories requiring State attention"
        query: |
          MATCH (t:Territory)
          WHERE t.heat >= 0.5
          RETURN t
          ORDER BY t.heat DESC
          LIMIT 100

  hydration_protocol:
    steps:
      1_select_sector:
        action: "Run sector selection query against KuzuDB"
        output: "List of territory IDs to hydrate"

      2_load_nodes:
        action: "Fetch full Territory data for selected IDs"
        query: |
          MATCH (t:Territory)
          WHERE t.id IN $territory_ids
          RETURN t

      3_load_edges:
        action: "Fetch edges between hydrated nodes"
        query: |
          MATCH (a:Territory)-[e]-(b:Territory)
          WHERE a.id IN $territory_ids AND b.id IN $territory_ids
          RETURN a.id, type(e), e, b.id

      4_build_networkx:
        action: "Convert Kuzu results to NetworkX DiGraph"
        code_pattern: |
          graph = nx.DiGraph()
          for territory in territories:
              graph.add_node(territory.id, **territory.to_dict())
          for edge in edges:
              graph.add_edge(edge.from_id, edge.to_id, **edge.properties)

      5_inject_into_engine:
        action: "Pass hydrated graph to SimulationEngine"
        note: "Engine code unchanged from Epoch 1"

  boundary_handling:
    description: "How to handle edges that cross sector boundaries"

    strategy: "ghost_nodes"
    explanation: |
      When a hydrated node has edges to non-hydrated nodes, we create "ghost nodes"
      with minimal data. Ghost nodes are read-only - changes to them are discarded.
      This prevents edge-of-sector artifacts.

    ghost_node_properties:
      territory:
        - "id"
        - "name"
        - "heat"
      sovereign:
        - "id"
        - "name"
        - "legitimacy"
    marker: "_is_ghost: true"

  sovereignty_hydration:
    description: "How to hydrate sovereignty claims along with territories"
    note: "Added in v1.1.0 for Dynamic Sovereignty"

    protocol:
      1_load_territories:
        action: "Load Territory nodes for sector (unchanged)"

      2_load_sovereigns:
        action: "Load all Sovereigns that claim any territory in sector"
        query: |
          MATCH (sov:Sovereign)-[:CLAIMS]->(t:Territory)
          WHERE t.id IN $territory_ids
          RETURN DISTINCT sov

      3_load_claims:
        action: "Load CLAIMS edges for hydrated territories"
        query: |
          MATCH (sov:Sovereign)-[c:CLAIMS]->(t:Territory)
          WHERE t.id IN $territory_ids
          RETURN sov.id, c, t.id

      4_build_networkx:
        action: "Convert to NetworkX with sovereignty layer"
        code_pattern: |
          # Territory nodes as before
          for territory in territories:
              graph.add_node(territory.id, node_type='Territory', **territory.to_dict())

          # Sovereign nodes
          for sovereign in sovereigns:
              graph.add_node(sovereign.id, node_type='Sovereign', **sovereign.to_dict())

          # CLAIMS edges (Sovereign -> Territory)
          for claim in claims:
              graph.add_edge(claim.sovereign_id, claim.territory_id,
                           edge_type='CLAIMS', **claim.properties)

# =============================================================================
# FLUSH STRATEGY
# =============================================================================

flush:
  description: |
    Flush is the process of writing Tactical Cache changes back to the Strategic Map.
    This happens at tick boundaries and must be atomic.

  flush_protocol:
    steps:
      1_diff_detection:
        action: "Compare current NetworkX state to pre-tick snapshot"
        method: "Track dirty flags or hash node dictionaries"
        output: "List of changed nodes and edges"

      2_batch_update:
        action: "Write changes to KuzuDB in single transaction"
        query_pattern: |
          // Update modified territories
          UNWIND $updates AS u
          MATCH (t:Territory {id: u.id})
          SET t.controller = u.controller,
              t.heat = u.heat,
              t.population = u.population,
              t.last_modified_tick = $current_tick

      3_chronicle_append:
        action: "Write snapshot to Chronicle tables"
        condition: "Every N ticks or on significant events"
        query: |
          CREATE (s:TerritorySnapshot {
            territory_id: $id,
            tick: $tick,
            controller: $controller,
            heat: $heat,
            population: $population
          })

      4_commit_transaction:
        action: "Commit KuzuDB transaction"
        on_failure: "Rollback and retry or halt simulation"

  atomicity:
    requirement: "Flush must be all-or-nothing"
    implementation: "KuzuDB transactions with explicit BEGIN/COMMIT/ROLLBACK"
    failure_handling: |
      If flush fails:
      1. Log error with full context
      2. Attempt retry (up to 3 times)
      3. If persistent failure, save NetworkX state to emergency file
      4. Halt simulation with user notification

  performance_optimization:
    batch_size: 1000
    description: "Process updates in batches to reduce transaction overhead"

    chronicle_frequency:
      default: "every_10_ticks"
      on_event: "UPRISING, RUPTURE, PHASE_TRANSITION"
      description: "Balance history granularity vs storage cost"

# =============================================================================
# QUERY PATTERNS
# =============================================================================

query_patterns:
  description: "Common query patterns for Epoch 2 operations"

  # ===========================================================================
  # SOVEREIGNTY QUERIES (v1.1.0)
  # ===========================================================================

  territories_by_sovereign:
    description: "Get all territories claimed by a specific sovereign"
    query: |
      MATCH (sov:Sovereign {id: $sovereign_id})-[c:CLAIMS]->(t:Territory)
      WHERE c.control_level > 0.0
      RETURN t.id, t.name, c.control_level, c.legal_status
      ORDER BY c.control_level DESC
    use_case: "Display sovereign's domain on map"

  effective_controller:
    description: "Find which sovereign has effective control of a territory"
    query: |
      MATCH (sov:Sovereign)-[c:CLAIMS]->(t:Territory {id: $territory_id})
      WHERE c.control_level >= 0.5
      RETURN sov.id, sov.name, c.control_level
      ORDER BY c.control_level DESC
      LIMIT 1
    use_case: "Determine who actually controls a territory"

  contested_territories:
    description: "Find territories with multiple sovereignty claims"
    query: |
      MATCH (t:Territory)
      WHERE SIZE([(s:Sovereign)-[c:CLAIMS]->(t) WHERE c.control_level > 0.1 | s]) > 1
      RETURN t.id, t.name,
             [(s:Sovereign)-[c:CLAIMS]->(t) | {sov: s.name, control: c.control_level}] AS claims
    use_case: "Identify civil war zones and dual power situations"

  fracture_candidates:
    description: "Find territories ripe for sovereignty fracture"
    query: |
      MATCH (sov:Sovereign)-[c:CLAIMS]->(t:Territory)
      WHERE c.control_level < 0.5 AND t.heat >= 0.6
      RETURN t.id, t.name, sov.name, c.control_level, t.heat
      ORDER BY c.control_level ASC
    use_case: "Predict where secession/revolution may occur"

  sovereignty_border:
    description: "Find the border between two sovereign entities"
    query: |
      MATCH (sov1:Sovereign {id: $sovereign_1})-[:CLAIMS]->(t1:Territory)
      MATCH (sov2:Sovereign {id: $sovereign_2})-[:CLAIMS]->(t2:Territory)
      MATCH (t1)-[:ADJACENT_TO]-(t2)
      RETURN t1.id AS territory_1, t2.id AS territory_2
    use_case: "Identify front lines between competing sovereigns"

  # ===========================================================================
  # TRADITIONAL QUERIES (updated for CLAIMS)
  # ===========================================================================

  front_line_detection:
    description: "Find territories at the boundary between factions"
    query: |
      // Find Player-claimed territories adjacent to State-claimed territories
      MATCH (player_sov:Sovereign {sovereignty_type: 'INSURGENT'})-[:CLAIMS]->(friendly:Territory)
      MATCH (state_sov:Sovereign {sovereignty_type: 'RECOGNIZED_STATE'})-[:CLAIMS]->(hostile:Territory)
      MATCH (friendly)-[:ADJACENT_TO]-(hostile)
      RETURN DISTINCT friendly.id, friendly.name, friendly.heat
    use_case: "Identify where conflict will occur next"

  supply_line_check:
    description: "Verify path exists between two player territories"
    query: |
      MATCH (player_sov:Sovereign {id: $player_sovereign_id})
      MATCH path = shortestPath(
        (a:Territory {id: $from})-[:ADJACENT_TO*]-(b:Territory {id: $to})
      )
      WHERE ALL(t IN nodes(path) WHERE
        EXISTS((player_sov)-[:CLAIMS {control_level: 0.5}]->(t))
        OR NOT EXISTS((:Sovereign)-[:CLAIMS]->(t))  // Neutral
      )
      RETURN path
    use_case: "Check if reinforcements can reach isolated territory"

  administrative_tree:
    description: "Get full hierarchy for a territory"
    query: |
      MATCH (t:Territory {id: $territory_id})
      MATCH path = (root:Territory)-[:ADMINISTERS*]->(t)
      WHERE NOT EXISTS(()-[:ADMINISTERS]->(root))
      RETURN nodes(path)
    use_case: "Understand jurisdictional chain (Federal → State → County → City)"

  encirclement_detection:
    description: "Find player territories completely surrounded by enemy"
    query: |
      MATCH (player_sov:Sovereign {id: $player_sovereign_id})-[:CLAIMS]->(player_t:Territory)
      WHERE NOT EXISTS {
        MATCH (player_t)-[:ADJACENT_TO]-(neighbor:Territory)
        WHERE EXISTS((player_sov)-[:CLAIMS]->(neighbor))
           OR NOT EXISTS((:Sovereign)-[:CLAIMS]->(neighbor))
      }
      RETURN player_t.id, player_t.name
    use_case: "Identify vulnerable positions for strategic planning"

  heat_spread_candidates:
    description: "Find territories likely to gain heat next tick"
    query: |
      MATCH (hot:Territory)-[:ADJACENT_TO]-(neighbor:Territory)
      WHERE hot.heat >= 0.7 AND neighbor.heat < 0.5
      RETURN neighbor.id, neighbor.heat, COUNT(hot) AS hot_neighbors
      ORDER BY hot_neighbors DESC
    use_case: "Predict State attention spread for evasion planning"

# =============================================================================
# MIGRATION PATH
# =============================================================================

migration:
  description: "How to transition from Epoch 1 to Epoch 2"

  epoch_1_preservation:
    principle: "Epoch 1 code remains 100% unchanged"
    reason: "Epoch 1 uses NetworkX + SQLite, which continues to work"
    coexistence: "Games can run in Epoch 1 mode (small scale) or Epoch 2 mode (continental)"

  initial_data_load:
    source: "US Census Bureau geographic data + manual curation"
    format: "GeoJSON or CSV with FIPS codes"
    ingestion: "tools/init_epoch2_db.py creates schema and loads initial data"

  phases:
    phase_1_skeleton:
      deliverables:
        - "tools/init_epoch2_db.py (schema creation)"
        - "Basic Territory and edge population"
        - "Test with 50 states + DC"
      timeline: "Epoch 2A"

    phase_2_hydration:
      deliverables:
        - "src/babylon/data/kuzu_manager.py"
        - "Hydration/flush protocol"
        - "Integration with SimulationEngine"
      timeline: "Epoch 2A-2B"

    phase_3_chronicle:
      deliverables:
        - "Chronicle tables"
        - "Historical query API"
        - "Narrative Director integration"
      timeline: "Epoch 2C"

    phase_4_full_scale:
      deliverables:
        - "Load all 74k territories"
        - "Performance optimization"
        - "Sector management UI"
      timeline: "Epoch 2D"

# =============================================================================
# TESTING STRATEGY
# =============================================================================

testing:
  unit_tests:
    location: "tests/unit/data/test_kuzu_manager.py"
    patterns:
      - "Test schema creation"
      - "Test node CRUD operations"
      - "Test edge CRUD operations"
      - "Test query execution"

  integration_tests:
    location: "tests/integration/test_epoch2_persistence.py"
    patterns:
      - "Test hydration from Kuzu to NetworkX"
      - "Test flush from NetworkX to Kuzu"
      - "Test round-trip data integrity"
      - "Test Chronicle snapshot creation"
      - "Test historical queries"

  fixtures:
    in_memory_kuzu:
      description: "Create ephemeral Kuzu database for tests"
      pattern: |
        @pytest.fixture
        def kuzu_db(tmp_path):
            db_path = tmp_path / "test.kuzu"
            db = kuzu.Database(str(db_path))
            conn = kuzu.Connection(db)
            init_schema(conn)
            yield conn
            # Cleanup handled by tmp_path

    sample_us_subset:
      description: "Small representative sample for tests"

      sovereigns:
        - id: "SOV_USA_FED"
          name: "United States Federal Government"
          sovereignty_type: "RECOGNIZED_STATE"
          legitimacy: 1.0
          color_hex: "#3C3B6E"
        - id: "SOV_PRC"
          name: "Provisional Revolutionary Command"
          sovereignty_type: "INSURGENT"
          legitimacy: 0.2
          color_hex: "#B22234"

      territories:
        - "US (Federal)"
        - "US-CA (California)"
        - "US-NV (Nevada)"
        - "US-AZ (Arizona)"
        - "US-CA-037 (LA County)"
        - "US-CA-059 (Orange County)"

      edges:
        ADMINISTERS:
          - ["US", "US-CA"]
          - ["US", "US-NV"]
          - ["US", "US-AZ"]
          - ["US-CA", "US-CA-037"]
          - ["US-CA", "US-CA-059"]
        ADJACENT_TO:
          - ["US-CA", "US-NV"]
          - ["US-CA", "US-AZ"]
          - ["US-NV", "US-AZ"]
          - ["US-CA-037", "US-CA-059"]
        CLAIMS:
          - from: "SOV_USA_FED"
            to: "US"
            control_level: 1.0
            legal_status: "DE_JURE"
          - from: "SOV_USA_FED"
            to: "US-CA"
            control_level: 0.9
            legal_status: "DE_JURE"
          - from: "SOV_USA_FED"
            to: "US-NV"
            control_level: 1.0
            legal_status: "DE_JURE"
          - from: "SOV_USA_FED"
            to: "US-AZ"
            control_level: 1.0
            legal_status: "DE_JURE"
          - from: "SOV_PRC"
            to: "US-CA-037"
            control_level: 0.4
            legal_status: "DE_FACTO"
            note: "Revolutionary command has partial control of LA County"
