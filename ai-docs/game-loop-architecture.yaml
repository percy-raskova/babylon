# Babylon Game Loop Architecture
# The Engine/State separation for Phase 2
#
# Core Insight: Data (State) is separate from Logic (Systems).
# The State is "what the dice land on." The Engine is "the physics of the throw."

meta:
  version: "4.0.0"
  created: "2024-12-07"
  updated: "2025-12-26"
  status: "implemented"
  phase: 2
  epoch_compatibility: "1 → 2 Bridge"
  principle: "State is pure data. Engine is pure transformation. They never mix."
  implementation_status: "1445 tests passing, 7 Systems in modular architecture"
  recent_additions:
    - "StruggleSystem (Agency Layer - George Floyd Dynamic)"
    - "SolidaritySystem (Proletarian Internationalism)"
    - "TerritorySystem (Layer 0 - Territorial Substrate)"
    - "Interceptor Architecture (Epoch 2 Bridge)"

# =============================================================================
# THE FUNDAMENTAL SEPARATION
# =============================================================================

architecture:
  name: "Data/Logic Separation"
  analogy:
    state: "The chessboard position"
    engine: "The rules of chess"

  properties:
    determinism: "Same WorldState + same Engine = same next WorldState. Always."
    replayability: "Save initial state, replay entire history."
    testability: "Feed state in, assert on state out."
    counterfactuals: "Load any state, modify parameter, run forward, compare."

# =============================================================================
# WORLD STATE (THE DATA)
# =============================================================================

world_state:
  purpose: "Immutable snapshot of all material conditions at a specific tick"
  principle: "State doesn't know HOW to change. It just IS."
  location: "src/babylon/models/world_state.py"

  actual_implementation:
    class: "WorldState(BaseModel)"
    frozen: true
    fields:
      tick:
        type: "int"
        description: "Current turn number (0-indexed)"
        default: 0

      entities:
        type: "dict[str, SocialClass]"
        description: "Map of Entity ID to SocialClass (graph nodes)"
        example: '{"C001": worker, "C002": owner}'

      relationships:
        type: "list[Relationship]"
        description: "Edges between entities (exploitation, solidarity, etc.)"
        example: "[Relationship(source_id='C001', target_id='C002', edge_type=EXPLOITATION)]"

      event_log:
        type: "list[str]"
        description: "Log of significant events (crossover, rupture)"

    methods:
      to_graph: "Convert to NetworkX DiGraph for formula application"
      from_graph: "Reconstruct WorldState from modified graph"
      add_entity: "Return new state with entity added (immutable)"
      add_relationship: "Return new state with relationship added (immutable)"
      add_event: "Return new state with event logged (immutable)"

  design_note: |
    Per ADR011, there are NO separate Economy or Politics classes.
    "The Economy is the sum of all EXTRACTS_FROM edges."
    All economic and political state is embedded in:
    - Entity attributes (wealth, ideology, organization, p_acquiescence, p_revolution)
    - Relationship attributes (value_flow, tension, edge_type)

  legacy_fields_removed:
    - economy (EconomicState) - merged into entity.wealth
    - politics (PoliticalState) - merged into entity.ideology, entity.p_*, relationship.tension
    - date (datetime) - not needed for Phase 2

# =============================================================================
# THE MATRYOSHKA HIERARCHY
# =============================================================================

geographic_hierarchy:
  principle: "Nested containers for spatial organization"
  insight: "Administrative structure, not ontological claim about legitimacy"

  levels:
    - world: "Top-level container"
    - country: "Nation-state (e.g., USA)"
    - region: "Multi-state area (e.g., Pacific Northwest)"
    - state: "Political subdivision (e.g., Oregon)"
    - city: "Urban center (e.g., Portland)"
    - neighborhood: "Local community (e.g., Alberta Arts District)"

  mlm_tw_tension:
    problem: "Settler-colonial boundaries are politically constructed, not natural"
    resolution: "Hierarchy is for STORAGE. Graph edges are for DYNAMICS."
    key_insight: "Relationships can cross hierarchy levels"
    example: "Neighborhood in Portland can have direct edge to mining operation in Congo"

  implementation_strategy:
    phase_2: "Start shallow: World -> SocialClass (just two nodes)"
    phase_3_plus: "Expand: World -> Country -> SocialClass (multiple per country)"
    principle: "Architecture supports arbitrary depth. Start minimal."

# =============================================================================
# SIMULATION ENGINE (THE LOGIC)
# =============================================================================

simulation_engine:
  purpose: "Pure transformation: Input State -> Calculation -> Output State"
  principle: "Engine doesn't know WHAT values are. It knows HOW to transform."

  role: "The Turn Processor"
  behavior: "Doesn't decide anything. Calculates and sets things in motion."

  actual_implementation:
    class: "SimulationEngine"
    location: "src/babylon/engine/simulation_engine.py"
    method: "run_tick(graph: nx.DiGraph, services: ServiceContainer, context: dict) -> None"
    note: "Engine orchestrates Systems; each System mutates the graph in place"

  step_function:
    signature: "step(state: WorldState, config: SimulationConfig) -> WorldState"
    pure: true
    deterministic: true
    steps:
      - "Convert WorldState to NetworkX DiGraph"
      - "Create ServiceContainer with config, event_bus, formulas, database"
      - "Run all 4 Systems in order via engine.run_tick()"
      - "Collect events from EventBus"
      - "Convert graph back to new WorldState"
      - "Return new state at tick + 1"

  service_container:
    class: "ServiceContainer"
    location: "src/babylon/engine/services.py"
    purpose: "Dependency injection for all simulation services"
    services:
      config: "SimulationConfig - all formula coefficients"
      database: "DatabaseConnection - SQLite persistence"
      event_bus: "EventBus - publish/subscribe for events"
      formulas: "FormulaRegistry - 12 hot-swappable formulas"

  systems:
    note: "Systems implement the System protocol and run in historical materialist order"
    location: "src/babylon/engine/systems/"
    count: 7

    1_imperial_rent:
      class: "ImperialRentSystem"
      file: "economic.py"
      purpose: "Extract imperial rent from exploitation edges (economic base)"
      formula: "calculate_imperial_rent(alpha, periphery_wages, periphery_consciousness)"
      effects:
        - "Worker.wealth -= rent"
        - "Owner.wealth += rent"
        - "Relationship.value_flow = rent"

    2_solidarity:
      class: "SolidaritySystem"
      file: "solidarity.py"
      sprint: "3.4.2 - Proletarian Internationalism"
      purpose: "Transmit class consciousness via SOLIDARITY edges"
      formula: "calculate_solidarity_transmission(source, target, strength, threshold)"
      effects:
        - "Target class_consciousness += delta"
        - "Emit CONSCIOUSNESS_TRANSMISSION events"
        - "Emit MASS_AWAKENING events when threshold crossed"

    3_consciousness:
      class: "ConsciousnessSystem"
      file: "ideology.py"
      sprint: "3.4.3 - George Jackson Refactor"
      purpose: "Route agitation to class consciousness or national identity (bifurcation)"
      formula: "calculate_ideological_routing(wage_change, solidarity_pressure, ...)"
      effects:
        - "If solidarity: class_consciousness += agitation"
        - "If no solidarity: national_identity += agitation"
        - "Agitation decays over time"

    4_survival:
      class: "SurvivalSystem"
      file: "survival.py"
      purpose: "Update survival probabilities for all entities"
      formulas:
        - "calculate_acquiescence_probability(wealth, threshold, steepness)"
        - "calculate_revolution_probability(organization, repression)"
      effects:
        - "SocialClass.p_acquiescence = P(S|A)"
        - "SocialClass.p_revolution = P(S|R)"

    5_struggle:
      class: "StruggleSystem"
      file: "struggle.py"
      sprint: "Agency Layer - George Floyd Dynamic"
      purpose: "Give political agency to oppressed classes through uprisings"
      algorithm: |
        1. Roll for EXCESSIVE_FORCE spark (repression * spark_scale)
        2. Check uprising condition: (spark OR P(S|R)>P(S|A)) AND agitation>threshold
        3. Execute uprising: destroy wealth, build solidarity, boost consciousness
      effects:
        - "Emit EXCESSIVE_FORCE events (the spark)"
        - "Emit UPRISING events (the explosion)"
        - "Emit SOLIDARITY_SPIKE events (bridge building)"
        - "wealth *= (1 - destruction_rate)"
        - "solidarity_strength += gain on SOLIDARITY edges"
        - "class_consciousness += boost"

    6_contradiction:
      class: "ContradictionSystem"
      file: "contradiction.py"
      purpose: "Accumulate tension and publish rupture events"
      effects:
        - "Relationship.tension += delta (clamped to [0, 1])"
        - "Publish 'rupture' event when tension reaches 1.0"

    7_territory:
      class: "TerritorySystem"
      file: "territory.py"
      sprint: "3.5.4 - Layer 0 Territorial Substrate"
      purpose: "Handle spatial dynamics, heat, eviction, spillover"
      effects:
        - "Heat accumulation for HIGH_PROFILE territories"
        - "Heat decay for LOW_PROFILE territories"
        - "Eviction pipeline when heat >= threshold"
        - "Heat spillover via ADJACENCY edges"

  event_bus:
    class: "EventBus"
    location: "src/babylon/engine/event_bus.py"
    purpose: "Publish/subscribe system for simulation events"
    events_published:
      # Economic events
      surplus_extraction: "Imperial rent extracted from worker to owner"
      economic_crisis: "Imperial rent pool depleted below critical threshold"
      # Consciousness events
      solidarity_awakening: "Periphery worker enters active struggle"
      consciousness_transmission: "Consciousness flows via SOLIDARITY edge"
      mass_awakening: "Target consciousness crosses awakening threshold"
      # Agency Layer events (Sprint: George Floyd Dynamic)
      excessive_force: "The Spark - Police brutality event"
      uprising: "The Explosion - Mass insurrection triggered"
      solidarity_spike: "The Bridge Building - Solidarity infrastructure created"
      # Contradiction events
      rupture: "When tension on an edge reaches 1.0"

# =============================================================================
# EPOCH 2 BRIDGE: INTERCEPTOR ARCHITECTURE
# =============================================================================
# Enables adversarial mechanics (State blocking Player actions) without UI changes

  interceptor_system:
    name: "Event Interceptors"
    status: "IMPLEMENTED"
    epoch_compatibility: "1 → 2 Bridge"
    pattern: "Chain of Responsibility"
    created: "2025-12-26"
    updated: "2025-12-26"

    rationale: |
      Epoch 2 introduces adversarial mechanics where the State can BLOCK or
      MODIFY player actions. Examples:
      - State blocks AGITATE action in high-surveillance territory
      - State intercepts SUPPLY_RUN and confiscates resources
      - Fascist faction disrupts ORGANIZE action in their territory

      The current Event Bus has: Signal → Emit
      Epoch 2 requires: Signal → Intercept → Emit (or Block)

      This is purely BACKEND LOGIC. The UI does not change.
      Interceptors are registered globally and evaluated in priority order.

    current_flow: |
      ┌─────────────┐     EMIT      ┌─────────────┐
      │   System    │ ────────────► │  EventBus   │ ────► Subscribers
      │  (Signal)   │               │             │
      └─────────────┘               └─────────────┘

    new_flow: |
      ┌─────────────┐    SIGNAL     ┌─────────────┐   INTERCEPT   ┌─────────────┐
      │   System    │ ────────────► │  EventBus   │ ────────────► │ Interceptor │
      │  (Action)   │               │  (Staging)  │               │   Chain     │
      └─────────────┘               └─────────────┘               └──────┬──────┘
                                                                         │
                                           ┌─────────────────────────────┤
                                           │                             │
                                           ▼                             ▼
                                    ┌─────────────┐               ┌─────────────┐
                                    │   BLOCKED   │               │    EMIT     │
                                    │  (Audit log)│               │ (Continue)  │
                                    └─────────────┘               └─────────────┘

    implementation:
      interceptor_module: "src/babylon/engine/interceptor.py"
      event_bus_module: "src/babylon/engine/event_bus.py"
      classes:
        InterceptResult: "Rich container with event + reason (frozen dataclass)"
        EventInterceptor: "Abstract Base Class for all interceptors"
        WorldContext: "Protocol for read-only world state"
        BlockedEvent: "Audit record for blocked events"
        SimpleWorldContext: "Basic WorldContext implementation for testing"
      methods:
        register_interceptor: "Add interceptor to the chain"
        unregister_interceptor: "Remove interceptor from the chain"
        publish: "Modified to run interceptor chain before emit"
        get_blocked_events: "Access audit log of blocked events"
        clear_blocked_events: "Clear the audit log"

    intercept_result:
      name: "InterceptResult"
      type: "frozen dataclass"
      location: "src/babylon/engine/interceptor.py"
      purpose: |
        Rich container for interceptor decisions that captures BOTH the event
        outcome AND the narrative reason. This is critical for Epoch 2's
        Gramscian Wire / player feedback systems.
      schema: |
        @dataclass(frozen=True)
        class InterceptResult:
            event: Event | None  # None = blocked
            reason: str = ""     # Narrative explanation (required if blocked)

            @classmethod
            def allow(cls, event: Event) -> InterceptResult
            @classmethod
            def block(cls, reason: str) -> InterceptResult
            @classmethod
            def modify(cls, new_event: Event, reason: str = "") -> InterceptResult

            @property
            def is_blocked(self) -> bool
            @property
            def is_modified(self) -> bool
      factory_methods:
        allow: "Pass event unchanged (reason empty)"
        block: "Stop event, reason REQUIRED for narrative"
        modify: "Transform event, reason optional"
      validation: "block() raises ValueError if reason is empty"

    interceptor_interface:
      name: "EventInterceptor"
      type: "ABC (Abstract Base Class)"
      location: "src/babylon/engine/interceptor.py"
      interface: |
        class EventInterceptor(ABC):
            @property
            @abstractmethod
            def name(self) -> str:
                """Interceptor name for debugging and audit logs."""
                ...

            @property
            def priority(self) -> int:
                """Priority for chain ordering (higher runs first). Default: 100"""
                return 100

            @abstractmethod
            def intercept(
                self, event: Event, context: WorldContext | None
            ) -> InterceptResult:
                """
                Process an event through this interceptor.

                Returns:
                    - InterceptResult.allow(event) to pass through
                    - InterceptResult.block(reason) to stop the chain
                    - InterceptResult.modify(new_event, reason) to transform
                """
                ...
      priority_ranges:
        90_100: "Security/State interceptors (block first)"
        50_89: "Faction/adversarial interceptors"
        10_49: "Resource/validation interceptors"
        1_9: "Logging/audit interceptors (run last)"

    world_context:
      type: "Protocol"
      location: "src/babylon/engine/interceptor.py"
      purpose: "Read-only view of world state for interceptor decisions"
      minimal_interface: |
        class WorldContext(Protocol):
            @property
            def tick(self) -> int: ...
      simple_implementation: |
        @dataclass
        class SimpleWorldContext:
            tick: int = 0
            data: dict[str, Any] = field(default_factory=dict)
      note: "Specific interceptors may require richer context implementations"

    pipeline_logic:
      steps:
        1_receive: "EventBus.publish(event, context) receives signal"
        2_fast_path: "If no interceptors registered, emit immediately (zero overhead)"
        3_sort: "Sort interceptors by priority (higher first: 100 before 50)"
        4_loop: "For each interceptor in sorted order:"
        5_intercept: "  result = interceptor.intercept(event, context)"
        6_check_blocked: "  If result.is_blocked: log WARNING, append to blocked_events, STOP"
        7_check_modified: "  If result.is_modified: log INFO with reason"
        8_chain: "  Update current_event = result.event, continue to next"
        9_emit: "After all interceptors pass: emit to subscribers"

      backwards_compatibility: |
        If no interceptors are registered, publish() uses the fast path:
        - No sorting overhead
        - No loop overhead
        - Epoch 1 events flow through with zero latency impact

    audit_requirements:
      blocked_events_channel:
        purpose: "Debug channel for intercepted events with narrative reasons"
        storage: "EventBus._blocked_events: list[BlockedEvent]"
        access: "EventBus.get_blocked_events() -> list[BlockedEvent]"
        record_format: |
          @dataclass(frozen=True)
          class BlockedEvent:
              event: Event           # The original event that was blocked
              interceptor_name: str  # Who blocked it
              reason: str            # Narrative reason for blocking
              blocked_at: datetime   # When it was blocked
        use_cases:
          - "Debug UI: Show blocked events with narrative reasons"
          - "Game UI: Display 'Action blocked: {reason}' to player"
          - "Testing: Assert specific events were blocked with expected reasons"
          - "Logging: Trace adversarial mechanics for debugging"
      logging:
        blocked: "logger.warning('Event {type} BLOCKED by {name}: {reason}')"
        modified: "logger.info('Event {type} MODIFIED by {name}: {reason}')"

    built_in_interceptors:
      state_attention_interceptor:
        priority: 10
        event_types: ["AGITATE", "ORGANIZE", "SUPPLY_RUN", "STRIKE"]
        behavior: |
          Checks if territory has State attention > threshold.
          If yes, probability of BLOCK based on attention level.
          On BLOCK: Emit SECURITY_BREACH event instead.
        integration: "ai-docs/state-attention-economy.yaml (Slice 2.9)"

      fascist_faction_interceptor:
        priority: 20
        event_types: ["ORGANIZE", "AGITATE", "ESTABLISH_CONTACT"]
        behavior: |
          Checks if territory has fascist_alignment > threshold.
          If yes, probability of BLOCK or MODIFY (reduced effect).
          May trigger VIGILANTISM counter-event.
        integration: "ai-docs/reactionary-subject.yaml (Slice 2.3)"

      resource_interceptor:
        priority: 30
        event_types: ["SUPPLY_RUN", "ARM_MILITIA", "RECRUIT"]
        behavior: |
          Checks if organization has sufficient resources.
          If not, BLOCK with reason "Insufficient Cadre Labor" etc.
        integration: "ai-docs/vanguard-economy.yaml (Slice 2.6)"

      fog_of_war_interceptor:
        priority: 40
        event_types: ["SOCIAL_INVESTIGATION", "ESTABLISH_CONTACT"]
        behavior: |
          Checks Mass_Receptivity of target territory.
          If too low (Desert), BLOCK intel-gathering actions.
          Returns reason "Masses will not speak to you."
        integration: "ai-docs/fog-of-war.yaml (Slice 2.10)"

    interceptor_chain:
      execution_order: "Sorted by priority (ascending)"
      short_circuit: "First BLOCK stops chain"
      modification_chaining: "MODIFY events pass to next interceptor"
      example: |
        Player issues AGITATE action in hostile territory:

        1. StateAttentionInterceptor (priority=10)
           - Territory surveillance = 0.8 (high)
           - Roll: 0.6 < 0.8 → BLOCK
           - Reason: "State security forces detained the organizers"
           - Emit: SECURITY_BREACH event
           - Chain STOPS

        2. FascistFactionInterceptor (priority=20)
           - Never reached (blocked at step 1)

        Player issues AGITATE action in friendly territory:

        1. StateAttentionInterceptor (priority=10)
           - Territory surveillance = 0.2 (low)
           - Roll: 0.7 > 0.2 → ALLOW
           - Chain continues

        2. FascistFactionInterceptor (priority=20)
           - fascist_alignment = 0.1 (minimal)
           - → ALLOW
           - Chain continues

        3. ResourceInterceptor (priority=30)
           - Cadre Labor available = 5 (sufficient)
           - → ALLOW
           - Chain continues

        4. No more interceptors → EMIT original event

    ui_implications:
      epoch_1: "None - interceptors are pure backend logic"
      epoch_2: |
        Game UI may display interceptor results:
        - "Action blocked: State forces intercepted your organizers"
        - "Action modified: Reduced effectiveness due to hostile territory"
        But this is Game UI (Player View), not Debug UI (God View).
        Debug UI shows interceptor chain execution for debugging.

    implementation_notes:
      backward_compatible: true
      existing_events: "Still emit directly if no interceptors registered"
      new_events: "Pass through interceptor chain"
      testing: "Interceptors are pure functions, easy to unit test"
      performance: "Interceptors are synchronous, no async overhead"

  formula_registry:
    class: "FormulaRegistry"
    location: "src/babylon/engine/formula_registry.py"
    purpose: "Hot-swappable formula lookup"
    formulas_registered: 12
    method: "get(name: str) -> FormulaFunc"

  legacy_note: |
    Per ADR011, Economy and Politics classes were DELETED.
    Their functionality is now in the 4 System classes above.
    ContradictionAnalysis class in systems/ is legacy but tension
    is now tracked directly on Relationship edges.

# =============================================================================
# ORDER OF OPERATIONS (THE DIALECTIC)
# =============================================================================

turn_order:
  principle: "Order encodes historical materialism: base determines superstructure"
  insight: "To model idealism, you would reverse steps 1 and 2"

  steps:
    1_economic_base:
      name: "Material Base Updates"
      quote: "Men must be in a position to live in order to be able to 'make history'. - Marx"
      actions:
        - "Calculate value flows between entities"
        - "Update wealth based on extraction"
        - "Process imperial rent transfers"

    2_superstructure:
      name: "Political Superstructure Reacts"
      actions:
        - "Update stability based on economic conditions"
        - "Recalculate class consciousness from inequality metrics"
        - "Adjust legitimacy based on material conditions"

    3_contradictions:
      name: "Contradiction Evolution"
      actions:
        - "Update tension levels in all contradictions"
        - "Check for rupture conditions (tension >= 1.0)"
        - "Check for synthesis conditions (tension <= 0.0)"
        - "Detect new contradictions arising from state"

    4_events:
      name: "Event Processing"
      actions:
        - "Fire events for threshold crossings"
        - "Log significant state changes"

    5_capture:
      name: "State Serialization"
      actions:
        - "Generate immutable WorldState snapshot"
        - "Record metrics"
        - "Prepare for next tick"

# =============================================================================
# FEEDBACK LOOPS
# =============================================================================

feedback_loops:
  principle: "Loops are IMPLICIT in order of operations, not explicitly coded"
  insight: "You don't code 'feedback loop'. You code 'Economy runs before Politics'."

  loop_1_rent_spiral:
    name: "The Rent Spiral"
    flow:
      - "Economy.update() transfers wealth from worker to owner"
      - "Worker wealth drops"
      - "P(S|A) drops (can't survive through compliance)"
      - "P(S|A) < P(S|R) -> Revolution becomes rational"
      - "Worker consciousness rises"
      - "Tension rises"
      - "(Next tick input)"

  loop_2_consciousness_decay:
    name: "The Consciousness Decay"
    flow:
      - "Worker gets raise (Wc increases)"
      - "Wc/Vc > 1 (labor aristocracy)"
      - "Consciousness drifts reactionary"
      - "Organization drops"
      - "P(S|R) drops"
      - "Worker accepts system again"
      - "(Next tick input)"

  loop_3_repression_trap:
    name: "The Repression Trap"
    flow:
      - "State increases repression"
      - "P(S|R) drops (revolution harder)"
      - "Workers comply short-term"
      - "But repression costs money -> Economy.gdp decreases"
      - "Owner cuts wages to fund police"
      - "Worker wealth drops"
      - "Eventually P(S|A) < P(S|R) despite repression"
      - "(Rupture delayed but intensified)"

# =============================================================================
# ARCHITECTURAL DECISION: DIRECT FORMULAS (ADR010)
# =============================================================================

architectural_decision:
  id: "ADR010"
  title: "Direct Entities + Formulas architecture"
  reference: "ai-docs/decisions.yaml"

  discovery: |
    Found THREE disconnected math systems:
    - formulas.py (40 tests, MLM-TW theory)
    - Economy class (0 tests, generic simulation)
    - Politics class (0 tests, generic simulation)

    Economy/Politics don't use the tested MLM-TW formulas at all.

  decision: |
    Bypass Economy/Politics classes entirely.
    SimulationEngine calls formulas.py directly on entities.

  components_used:
    - "babylon.systems.formulas (all functions)"
    - "babylon.systems.contradiction_analysis.ContradictionAnalysis"
    - "babylon.models.entities.SocialClass"
    - "babylon.models.entities.Relationship"

  components_deleted:
    - "babylon.core.economy.Economy (DELETED per ADR011)"
    - "babylon.core.politics.Politics (DELETED per ADR011)"

# =============================================================================
# FORMULA-TO-ENTITY WIRING
# =============================================================================

formula_wiring:
  principle: "Explicit mapping from formula parameters to entity/config fields"

  imperial_rent:
    formula: "calculate_imperial_rent(alpha, periphery_wages, periphery_consciousness)"
    inputs:
      alpha: "SimulationConfig.extraction_efficiency"
      periphery_wages: "Worker.wealth / (Worker.wealth + Owner.wealth)"
      periphery_consciousness: "(Worker.ideology + 1) / 2  # map [-1,1] to [0,1]"
    outputs:
      - "Relationship.value_flow = rent"
    effects:
      - "Worker.wealth -= rent"
      - "Owner.wealth += rent"

  labor_aristocracy:
    formula: "calculate_labor_aristocracy_ratio(core_wages, value_produced)"
    inputs:
      core_wages: "SocialClass.wealth"
      value_produced: "Relationship.value_flow (for that class)"
    outputs:
      - "ratio (used for consciousness drift)"
    effects:
      - "None directly (input to other calculations)"

  consciousness_drift:
    formula: "calculate_consciousness_drift(core_wages, value_produced, current_consciousness, k, lambda)"
    inputs:
      core_wages: "SocialClass.wealth"
      value_produced: "Relationship.value_flow"
      current_consciousness: "SocialClass.ideology"
      k: "SimulationConfig.consciousness_sensitivity"
      lambda: "2.25 (constant)"
    outputs:
      - "delta_ideology"
    effects:
      - "SocialClass.ideology += delta_ideology (clamped to [-1, 1])"

  acquiescence_probability:
    formula: "calculate_acquiescence_probability(wealth, subsistence_threshold, steepness_k)"
    inputs:
      wealth: "SocialClass.wealth"
      subsistence_threshold: "SimulationConfig.subsistence_threshold"
      steepness_k: "SimulationConfig.survival_steepness"
    outputs:
      - "probability"
    effects:
      - "SocialClass.p_acquiescence = probability"

  revolution_probability:
    formula: "calculate_revolution_probability(cohesion, repression)"
    inputs:
      cohesion: "SocialClass.organization"
      repression: "SimulationConfig.repression_level"
    outputs:
      - "probability"
    effects:
      - "SocialClass.p_revolution = probability"

  tension_update:
    formula: "ContradictionAnalysis.update_tension(contradiction_id, delta)"
    inputs:
      delta: "Derived from entity state changes (e.g., wealth gap increase)"
    outputs:
      - "ResolutionOutcome (if rupture/synthesis)"
    effects:
      - "Contradiction.tension updated"
      - "Contradiction.resolved = True (if phase transition)"

# =============================================================================
# SIMULATION CONFIG
# =============================================================================

simulation_config:
  purpose: "Global coefficients and parameters for the simulation"
  location: "src/babylon/models/config.py"
  implementation: "Pydantic BaseModel (frozen=True)"

  fields:
    extraction_efficiency:
      type: "Coefficient"  # [0, 1]
      default: 0.8
      description: "Alpha (α) - how efficiently the core extracts value"

    consciousness_sensitivity:
      type: "Coefficient"
      default: 0.5
      description: "k - how quickly consciousness responds to material conditions"

    consciousness_decay_lambda:
      type: "PositiveFloat"
      default: 0.1
      description: "λ - decay rate for consciousness without material reinforcement"

    subsistence_threshold:
      type: "Currency"
      default: 0.3
      description: "Minimum wealth for survival through compliance"

    survival_steepness:
      type: "PositiveFloat"
      default: 10.0
      description: "How sharp the survival sigmoid transition is"

    repression_level:
      type: "Probability"
      default: 0.5
      description: "State capacity for violence"

    initial_worker_wealth:
      type: "Currency"
      default: 0.5
      description: "Starting wealth for periphery worker"

    initial_owner_wealth:
      type: "Currency"
      default: 0.5
      description: "Starting wealth for core owner"

    loss_aversion_lambda:
      type: "PositiveFloat"
      default: 2.25
      description: "Kahneman-Tversky coefficient - losses felt 2.25x more than gains"

    tension_accumulation_rate:
      type: "Coefficient"
      default: 0.05
      description: "Rate at which tension accumulates from wealth gaps"

# =============================================================================
# PHASE 2 SUCCESS CRITERIA
# =============================================================================

success_criteria:
  status: "ACHIEVED"
  test_count: 704
  verification: "tests/unit/engine/ and tests/integration/"

  core_test:
    description: "Run 100 turns, observe deterministic outcomes"
    status: "PROVEN - test_hundred_turns_deterministic passes"
    example: |
      def test_repression_triggers_revolution():
          state = create_initial_state()

          # Turn 0-49: High repression, worker quiet
          for _ in range(50):
              state = advance_turn(state)
          assert state.worker.p_revolution < 0.3

          # Turn 50: Reduce repression
          state.repression = 0.1

          # Turn 51: Revolution probability spikes
          state = advance_turn(state)
          assert state.worker.p_revolution > 0.7

  properties_verified:
    determinism:
      status: "PROVEN"
      test: "test_hundred_turns_deterministic"
      evidence: "Same inputs always produce same outputs"

    parameter_responsiveness:
      status: "PROVEN"
      test: "TestStepTensionRate, TestStepConsciousnessDrift"
      evidence: "Parameter changes cause predictable state transitions"

    feedback_loops:
      status: "PROVEN"
      tests:
        - "TestRentSpiral - extraction impoverishes worker"
        - "TestConsciousnessFeedbackLoop - exploited workers become revolutionary"
        - "TestRepressionTrap - high repression delays but doesn't prevent revolution"
      evidence: "Feedback loops produce compounding effects over time"

    phase_transitions:
      status: "PROVEN"
      test: "test_thousand_tick_stability"
      evidence: "Thresholds trigger bounded state transitions"

    save_load:
      status: "TRIVIAL (Pydantic)"
      evidence: "WorldState.model_dump_json() / model_validate_json()"

# =============================================================================
# IMPLEMENTATION NOTES
# =============================================================================

implementation:

  abstract_base_approach:
    recommendation: "Use abstract base or protocol for geographic hierarchy"
    rationale: "Allows shallow start (2 nodes) with deep expansion later"
    pattern: |
      class GeographicEntity(Protocol):
          id: str
          name: str
          parent_id: Optional[str]
          children_ids: List[str]

      # Phase 2: Just SocialClass implements this
      # Phase 3+: Country, Region, City also implement

  state_immutability:
    recommendation: "WorldState should be treated as immutable"
    pattern: "advance_turn(state) -> new_state, not state.advance()"
    benefit: "Enables diffing, history, counterfactuals"

  engine_statelessness:
    recommendation: "Engine can hold configuration but not game state"
    allowed: "Engine stores formulas, coefficients, subsystem references"
    forbidden: "Engine stores current tick, entity values, etc."
