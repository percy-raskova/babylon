# NiceGUI Development Patterns & Quick Reference
# ================================================
# Distilled from Babylon GUI development sessions (Dec 2025)
# Purpose: Prevent repeating past mistakes, provide quick solutions
#
# C7 Library ID: /websites/nicegui_io (1944 snippets, High reputation)

meta:
  version: "1.0.0"
  updated: "2025-12-14"
  purpose: |
    Token-efficient reference for NiceGUI patterns learned during
    Synopticon dashboard development. Consult when:
    - Building new UI components
    - Debugging layout issues
    - Writing UI tests
    - Handling async callbacks
  cross_references:
    - "ai-docs/design-system.yaml (colors, aesthetic)"
    - "ai-docs/synopticon-spec.yaml (observer architecture)"

# =============================================================================
# LAYOUT PATTERNS (Most Critical Section)
# =============================================================================

layout:

  flex_height_trap:
    problem: |
      Child elements overflow parent instead of respecting height constraints.
      This is the #1 NiceGUI layout gotcha.
    cause: |
      In CSS flexbox, a flex child's min-height defaults to 'auto', which means
      it won't shrink below its content size. Nested flex containers compound this.
    solution: |
      Add `min-height: 0` to flex children that should shrink to fit.
    pattern: |
      # BAD - Child will overflow
      with ui.column().style("height: 100%"):
          ui.scroll_area()  # Overflows!

      # GOOD - Child respects parent height
      with ui.column().style("height: 100%"):
          with ui.element("div").style("flex: 1; min-height: 0"):
              ui.scroll_area()  # Now scrolls properly!
    our_constants: |
      CONTAINER_STYLE = "flex: 1; min-height: 0"  # Use on wrapper divs

  grid_columns:
    description: "Custom grid layouts with CSS grid-template-columns"
    patterns:
      equal_columns: 'ui.grid(columns=3)'
      percentage_split: 'ui.grid(columns="1fr 2fr 1fr")  # 25%-50%-25%'
      mixed_widths: 'ui.grid(columns="auto 80px 1fr 2fr")'
      full_width: '.classes("w-full gap-4")'
    example: |
      # 3-column dashboard: 25% - 50% - 25%
      with ui.grid(columns="1fr 2fr 1fr").classes("w-full gap-4").style("height: calc(100vh - 80px)"):
          # Left panel
          with ui.column().style("height: 100%"):
              ...

  scroll_area_sizing:
    problem: "scroll_area doesn't fill available space or doesn't scroll"
    solution: |
      1. Wrap in a div with explicit flex styling
      2. Apply both classes AND style to the scroll_area
    pattern: |
      # Wrapper provides the flex context
      with ui.element("div").style("flex: 1; min-height: 0; display: flex"):
          ui.scroll_area().classes("w-full").style("flex: 1; min-height: 0")
    auto_scroll: |
      # Scroll to bottom after adding content
      scroll_area.scroll_to(percent=1.0)

  responsive_height:
    viewport_minus_header: 'style("height: calc(100vh - 80px)")'
    full_height_column: 'style("height: 100%")'
    flex_fill: 'style("flex: 1; min-height: 0")'

# =============================================================================
# COMPONENT PATTERNS
# =============================================================================

components:

  class_structure:
    description: "Our standard pattern for reusable UI components"
    template: |
      class MyComponent:
          """Docstring with styling info."""

          # Design system constants
          CONTAINER_CLASSES = "bg-[#050505] border border-[#404040] p-4"
          CONTAINER_STYLE = "flex: 1; min-height: 0"

          def __init__(self) -> None:
              """Initialize with empty state."""
              self._internal_state: list[str] = []
              self._build_ui()

          def _build_ui(self) -> None:
              """Construct UI elements."""
              with ui.scroll_area().classes(self.CONTAINER_CLASSES).style(self.CONTAINER_STYLE) as sa:
                  self.scroll_area: Any = sa
                  self._content: Any = ui.column().classes("w-full")

          def public_method(self, data: str) -> None:
              """Public API for updating the component."""
              self._internal_state.append(data)
              with self._content:
                  ui.label(data)
              self.scroll_area.scroll_to(percent=1.0)

  storing_references:
    description: "Store UI element references for later manipulation"
    pattern: |
      # Use 'as' syntax with context manager
      with ui.scroll_area() as scroll_area:
          self.scroll_area: Any = scroll_area  # Type hint avoids issues

      # Or assign directly
      self.label: Any = ui.label("text")

  design_system_colors:
    description: "Using hex colors in Tailwind classes"
    pattern: |
      # Arbitrary value syntax: [#HEXCODE]
      ui.label("text").classes("text-[#39FF14]")  # data_green
      ui.element().classes("bg-[#050505]")        # void
      ui.element().classes("border-[#404040]")   # dark_metal
    our_palette:
      void: "#050505"
      wet_concrete: "#1A1A1A"
      dark_metal: "#404040"
      silver_dust: "#C0C0C0"
      data_green: "#39FF14"
      grow_light_purple: "#9D00FF"
      exposed_copper: "#FFD700"
      phosphor_burn_red: "#D40000"

# =============================================================================
# ASYNC PATTERNS
# =============================================================================

async_patterns:

  callback_handling:
    problem: |
      NiceGUI buttons accept both sync and async callbacks.
      Need to properly detect and await async callbacks.
    solution: |
      import inspect

      async def _invoke_callback(self, callback: Callable | None) -> None:
          if callback is not None:
              if inspect.iscoroutinefunction(callback):
                  await callback()
              else:
                  callback()
    button_handler: |
      # Button handlers should be async to support both callback types
      async def _handle_click(self) -> None:
          await self._invoke_callback(self._on_click)

  blocking_operations:
    problem: "Simulation step blocks the GUI thread"
    solution: |
      # Use asyncio.to_thread for CPU-bound or blocking operations
      async def on_step() -> None:
          await asyncio.to_thread(simulation.step)
          refresh_ui()

  timer_pattern:
    description: "Periodic updates during play mode"
    critical: "ui.timer MUST be called inside the page function, not at module level"
    pattern: |
      def main_page() -> None:
          # ... UI setup ...

          # Timer MUST be here, inside the page function
          ui.timer(interval=1.0, callback=run_loop)

      # NOT at module level!
    one_shot: |
      # Single delayed execution
      ui.timer(1.0, lambda: ui.notify('Done!'), once=True)

  awaiting_button:
    description: "Sequential UI flow waiting for button clicks"
    pattern: |
      @ui.page('/')
      async def page():
          button = ui.button('Continue')
          await button.clicked()
          ui.label('Step 1 complete')
          await button.clicked()
          ui.label('Step 2 complete')

# =============================================================================
# DATA COMPONENTS
# =============================================================================

data_components:

  echart:
    initialization: |
      self.echart: Any = ui.echart({
          'backgroundColor': '#050505',
          'xAxis': {'type': 'category', 'data': []},
          'yAxis': {'type': 'value'},
          'series': [{'type': 'line', 'data': [], 'lineStyle': {'color': '#39FF14'}}],
      }).classes("w-full h-full")
    update_pattern: |
      # CRITICAL: Must call .update() after modifying options!
      self.echart.options['xAxis']['data'] = new_x_data
      self.echart.options['series'][0]['data'] = new_y_data
      self.echart.update()  # <-- Don't forget this!
    dynamic_formatter: |
      # JavaScript expression with ':' prefix
      'yAxis': {'axisLabel': {':formatter': 'value => "$" + value'}}
    click_handler: |
      ui.echart({...}, on_point_click=lambda e: ui.notify(f'Clicked: {e}'))

  json_editor:
    initialization: |
      self.editor: Any = ui.json_editor(
          {'content': {'json': initial_data}},
          on_change=lambda e: handle_change(e),
      )
    read_only_mode: |
      # Set read-only AFTER creation using run_editor_method
      self.editor.run_editor_method('updateProps', {'readOnly': True})
    update_content: |
      self.editor.run_editor_method('set', {'json': new_data})
    expand_collapse: |
      editor.run_editor_method(':expand', '[]', 'path => true')  # Expand all
      editor.run_editor_method('collapse', [])  # Collapse all
    get_data: |
      # Async - must await
      data = await editor.run_editor_method('get')

  scroll_area:
    auto_scroll_bottom: 'scroll_area.scroll_to(percent=1.0)'
    scroll_events: |
      ui.scroll_area(on_scroll=lambda e: handle_scroll(e.vertical_percentage))

# =============================================================================
# TESTING PATTERNS
# =============================================================================

testing:

  pytest_config:
    pyproject_toml: |
      [tool.pytest.ini_options]
      asyncio_mode = "auto"
    pytest_ini: |
      [pytest]
      asyncio_mode = auto
      addopts = -p nicegui.testing.user_plugin

  user_fixture:
    description: "Simulates user interaction without real browser"
    basic_test: |
      from nicegui.testing import User

      async def test_button_click(user: User) -> None:
          await user.open('/')
          await user.should_see('Click me')
          user.find(ui.button).click()
          await user.should_see('Clicked!')
    form_interaction: |
      user.find('Username').type('user1')
      user.find('Password').type('pass1').trigger('keydown.enter')

  avoiding_context_errors:
    problem: |
      Unit tests creating NiceGUI components fail with context errors
      because there's no active NiceGUI client/page context.
    solutions:
      - "Test component logic separately from UI creation"
      - "Use asyncio.run() wrapper for async handlers"
      - "Mock NiceGUI elements when testing business logic"
    pattern: |
      # Test async callback logic without creating UI
      def test_async_callback_detection():
          async def async_handler():
              pass
          def sync_handler():
              pass

          # Test the detection logic, not the UI
          assert inspect.iscoroutinefunction(async_handler)
          assert not inspect.iscoroutinefunction(sync_handler)

  multiple_users:
    pattern: |
      async def test_chat(create_user):
          userA = create_user()
          userB = create_user()
          await userA.open('/')
          await userB.open('/')
          # Test multi-user interactions

# =============================================================================
# STYLING QUICK REFERENCE
# =============================================================================

styling:

  dark_mode:
    enable: |
      def main_page() -> None:
          ui.dark_mode().enable()
          # ... rest of page
    page_decorator: |
      @ui.page('/dark', dark=True)
      def dark_page():
          ...

  common_tailwind:
    layout:
      - "w-full h-full"
      - "flex flex-col flex-row"
      - "gap-2 gap-4"
      - "p-2 p-4"
      - "items-center justify-between"
    text:
      - "font-mono"
      - "text-sm text-xs text-xl text-2xl"
      - "uppercase tracking-wider"
      - "leading-tight leading-relaxed"
    borders:
      - "border border-[#404040]"
      - "rounded rounded-md"
    overflow:
      - "overflow-auto overflow-hidden"
      - "break-all"  # For long text wrapping

  custom_tailwind_classes:
    description: "Define reusable classes via @layer"
    pattern: |
      ui.add_head_html('''
          <style type="text/tailwindcss">
              @layer components {
                  .terminal-output {
                      @apply bg-[#050505] border border-[#404040] p-4 font-mono text-sm;
                  }
              }
          </style>
      ''')

# =============================================================================
# GOTCHAS CHECKLIST
# =============================================================================

gotchas:
  - issue: "ui.timer at module level"
    fix: "Move inside page function"

  - issue: "scroll_area doesn't scroll"
    fix: "Wrap in div with 'flex: 1; min-height: 0'"

  - issue: "echart not updating"
    fix: "Call echart.update() after modifying options"

  - issue: "json_editor not read-only"
    fix: "run_editor_method('updateProps', {'readOnly': True})"

  - issue: "Flex child overflows parent"
    fix: "Add 'min-height: 0' to flex children"

  - issue: "Async callback not awaited"
    fix: "Use inspect.iscoroutinefunction() to detect"

  - issue: "Button click blocks UI"
    fix: "Use asyncio.to_thread() for blocking ops"

  - issue: "Test fails with context error"
    fix: "Test logic separately or use User fixture"

  - issue: "Grid not full width"
    fix: "Add .classes('w-full')"

  - issue: "Height calc not working"
    fix: "Use style() not classes() for calc()"

# =============================================================================
# ENTRY POINTS
# =============================================================================

entry_points:

  ui_run:
    basic: |
      ui.run(main_page, title="Babylon", dark=True, reload=False, port=6969)
    parameters:
      title: "Browser tab title"
      dark: "Enable dark mode globally"
      reload: "Auto-reload on file changes (dev mode)"
      port: "Server port"

  module_guard:
    description: "Required for NiceGUI apps"
    pattern: |
      if __name__ in {"__main__", "__mp_main__"}:
          ui.run(main_page)
    why: |
      NiceGUI uses multiprocessing for auto-reload.
      "__mp_main__" catches the spawned process.

# =============================================================================
# REFERENCES
# =============================================================================

references:
  c7_library: "/websites/nicegui_io"
  official_docs: "https://nicegui.io/documentation"
  our_components:
    - "src/babylon/ui/main.py (4-panel dashboard)"
    - "src/babylon/ui/components.py (SystemLog, TrendPlotter, StateInspector)"
    - "src/babylon/ui/terminal.py (NarrativeTerminal with typewriter)"
    - "src/babylon/ui/controls.py (ControlDeck with async callbacks)"
