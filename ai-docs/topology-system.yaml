# Topology System Specification
# Machine-readable reference for percolation theory implementation
#
# This document specifies the graph structure, metrics, and formulas
# used to model revolutionary organization via percolation theory.

meta:
  version: "1.2.0"
  updated: "2025-12-12"
  status: "IMPLEMENTED"
  tests: 85  # 34 unit + 21 integration + 30 phase transition (Sprint 3.3: 4-phase model)

overview:
  purpose: |
    Model revolutionary organization as a percolation problem on solidarity graphs.
    Detect phase transitions from atomized (gaseous) to organized (liquid) states.
    Track network resilience to targeted repression (purge simulation).

  core_insight: |
    Revolution requires not just radicalized workers, but radicalized workers
    who can coordinate. The graph structure determines which equilibrium
    (revolution vs fascism) the system reaches during crisis.

# =============================================================================
# TECHNOLOGY: GRAPH ABSTRACTION LAYER
# =============================================================================

technology:
  name: "Graph Abstraction Layer"
  status: "SPECIFICATION (MVP uses NetworkX directly)"
  approach: "Interface-First"
  updated: "2025-12-26"

  description: |
    The topology layer is DECOUPLED from any specific graph library.
    We define a GraphProtocol interface that abstracts graph operations.
    Concrete implementations (Adapters) provide the actual functionality.

    This enables:
    - Swappable backends without changing System code
    - Testing with mock graphs
    - Future migration to persistent graph databases (DuckDB + DuckPGQ)

    IMPORTANT: NetworkX is an IMPLEMENTATION DETAIL, not the ARCHITECTURE.
    The ARCHITECTURE is the GraphProtocol interface.

  graph_protocol:
    name: "GraphProtocol"
    location: "src/babylon/engine/graph_protocol.py (planned)"
    type: "typing.Protocol"
    status: "SPECIFICATION"

    purpose: |
      Abstract interface for graph operations. All Systems interact with the
      graph through this protocol, never directly with NetworkX or DuckDB.

    core_methods:
      node_operations:
        - name: "add_node"
          signature: "add_node(node_id: str, node_type: str, **attrs) -> None"
          description: "Add a node with type marker and attributes"

        - name: "get_node"
          signature: "get_node(node_id: str) -> dict[str, Any]"
          description: "Retrieve node attributes by ID"

        - name: "update_node"
          signature: "update_node(node_id: str, **attrs) -> None"
          description: "Update node attributes (partial update)"

        - name: "remove_node"
          signature: "remove_node(node_id: str) -> None"
          description: "Remove node and all incident edges"

        - name: "get_nodes_by_type"
          signature: "get_nodes_by_type(node_type: str) -> Iterator[tuple[str, dict]]"
          description: "Iterate over nodes of a specific type"

      edge_operations:
        - name: "add_edge"
          signature: "add_edge(source: str, target: str, edge_type: str, **attrs) -> None"
          description: "Add directed edge with type and attributes"

        - name: "get_edge"
          signature: "get_edge(source: str, target: str, edge_type: str) -> dict[str, Any]"
          description: "Retrieve edge attributes"

        - name: "update_edge"
          signature: "update_edge(source: str, target: str, edge_type: str, **attrs) -> None"
          description: "Update edge attributes (partial update)"

        - name: "remove_edge"
          signature: "remove_edge(source: str, target: str, edge_type: str) -> None"
          description: "Remove specific edge"

        - name: "get_edges_by_type"
          signature: "get_edges_by_type(edge_type: str) -> Iterator[tuple[str, str, dict]]"
          description: "Iterate over edges of a specific type"

      traversal_operations:
        - name: "neighbors"
          signature: "neighbors(node_id: str, edge_type: str | None = None) -> Iterator[str]"
          description: "Get neighbor node IDs, optionally filtered by edge type"

        - name: "predecessors"
          signature: "predecessors(node_id: str, edge_type: str | None = None) -> Iterator[str]"
          description: "Get nodes pointing TO this node"

        - name: "successors"
          signature: "successors(node_id: str, edge_type: str | None = None) -> Iterator[str]"
          description: "Get nodes this node points TO"

      aggregate_operations:
        - name: "node_count"
          signature: "node_count(node_type: str | None = None) -> int"
          description: "Count nodes, optionally by type"

        - name: "edge_count"
          signature: "edge_count(edge_type: str | None = None) -> int"
          description: "Count edges, optionally by type"

  adapters:
    inmemory_adapter:
      name: "InMemoryAdapter"
      status: "CURRENT (MVP)"
      location: "Currently inline in WorldState.to_graph()/from_graph()"
      future_location: "src/babylon/engine/adapters/inmemory_adapter.py"
      backing: "networkx.DiGraph"
      epoch_compatibility: "Epoch 1 (direct) and Epoch 2 (via interface)"

      characteristics:
        - "In-memory (fast, but limited by RAM)"
        - "Pure Python (no external dependencies beyond NetworkX)"
        - "Serializes to JSON via model_dump()/model_validate()"
        - "Well-tested (50+ topology tests)"

      current_implementation: |
        Currently, WorldState.to_graph() and from_graph() serve as the de facto
        adapter. The GraphProtocol will formalize this interface.

      limitations:
        - "No persistence - graph lost on process exit"
        - "RAM-bound - large scenarios may hit memory limits"
        - "No native graph query language"

    columnar_adapter:
      name: "ColumnarAdapter"
      status: "PLANNED (Epoch 3)"
      location: "src/babylon/engine/adapters/columnar_adapter.py (planned)"
      backing: "DuckDB + DuckPGQ extension"
      epoch_compatibility: "Epoch 3+"

      characteristics:
        - "Persistent (survives process restart)"
        - "OLAP-optimized (fast aggregations, analytics)"
        - "Native Parquet I/O (large-scale scenarios)"
        - "SQL/GQL hybrid queries via DuckPGQ"
        - "Columnar storage (efficient for time-series analysis)"

      benefits:
        - "Unified Ledger + Topology in single database"
        - "Native support for scenario serialization"
        - "Better performance for large graphs (>10K nodes)"
        - "Built-in graph algorithms via DuckPGQ"

      migration_strategy: |
        1. Implement GraphProtocol interface
        2. Create ColumnarAdapter implementing the protocol
        3. Add configuration flag to select adapter
        4. Migrate Ledger layer to DuckDB (unification)
        5. Deprecate SQLite once validated

  # -------------------------------------------------------------------------
  # TECHNOLOGY BRIDGE: Epoch 1 → Epoch 2 Migration
  # -------------------------------------------------------------------------
  technology_bridge:
    name: "Epoch 1 → 2 Bridge"
    status: "TRANSITION PLAN"
    updated: "2025-12-26"

    principle: |
      The transition from Epoch 1 to Epoch 2 is a GRADUAL migration from
      direct NetworkX access to GraphProtocol-mediated access. This allows
      existing code to continue working while new code uses the abstraction.

    epochs:
      epoch_1:
        name: "The Demonstration"
        graph_access: "Direct NetworkX"
        pattern: |
          WorldState.to_graph() returns raw NetworkX DiGraph.
          Systems access graph.nodes['C001']['wealth'] directly.
          No interface abstraction - NetworkX IS the API.
        status: "CURRENT IMPLEMENTATION"
        constraint: |
          This is acceptable for Epoch 1 because:
          - Small scale (4 SocialClass nodes, few Territories)
          - No persistence requirements during tick
          - Developer-facing (Debug UI only)

      epoch_2:
        name: "The Game"
        graph_access: "GraphProtocol ONLY"
        pattern: |
          Systems interact ONLY via GraphProtocol interface.
          WorldState.to_graph() returns a GraphProtocol-wrapped adapter.
          All direct NetworkX calls are prohibited in System code.
        constraint: |
          Required for Epoch 2 because:
          - Larger scale (100+ nodes for scenarios)
          - Fog of War requires filtered views
          - Agent abstraction requires clean separation
        enforcement: |
          Linting rules can detect direct nx.* imports in Systems.
          All System.step() receives GraphProtocol, not DiGraph.

      epoch_3:
        name: "The Platform"
        graph_access: "ColumnarAdapter (DuckDB + DuckPGQ)"
        pattern: |
          Same GraphProtocol interface, different backing store.
          Swap InMemoryAdapter for ColumnarAdapter in config.
          Zero changes to System code.
        benefit: |
          Persistent graphs, SQL analytics, Parquet export.

    migration_stages:
      stage_1:
        name: "Interface Definition"
        epoch: "Late Epoch 1"
        tasks:
          - "Define GraphProtocol as typing.Protocol"
          - "Document all required methods (16 methods)"
          - "Create InMemoryAdapter wrapping NetworkX"
        status: "SPECIFICATION COMPLETE"

      stage_2:
        name: "Adapter Implementation"
        epoch: "Early Epoch 2"
        tasks:
          - "Implement InMemoryAdapter with full test coverage"
          - "Update WorldState.to_graph() to return wrapped adapter"
          - "Refactor one System to use GraphProtocol (proof of concept)"
        status: "PLANNED"

      stage_3:
        name: "System Migration"
        epoch: "Epoch 2"
        tasks:
          - "Refactor all 8 Systems to use GraphProtocol"
          - "Add lint rules to prevent direct NetworkX imports"
          - "Validate via integration tests"
        status: "PLANNED"

      stage_4:
        name: "Backend Swap"
        epoch: "Epoch 3"
        tasks:
          - "Implement ColumnarAdapter (DuckDB + DuckPGQ)"
          - "Add configuration to select adapter"
          - "Performance benchmarking: InMemory vs Columnar"
        status: "FUTURE"

    explicit_statement: |
      FOR EPOCH 1: We use direct NetworkX. This is acceptable.
      FOR EPOCH 2: We interact ONLY via the GraphProtocol interface.

      The GraphProtocol is the architectural boundary. NetworkX is an
      implementation detail that can be swapped without changing System code.

  franchise_model:
    name: "The Franchise Model"
    status: "DESIGN PRINCIPLE"

    principle: |
      Strategic Agents (e.g., Revolutionary Organization, State) are DISTINCT
      from Graph Nodes (e.g., Cells, Territories, SocialClasses). Agents
      MANIPULATE the graph via the GraphProtocol interface - they are external
      actors, not graph members.

      This is like a franchise business:
      - The Franchise Owner (Agent) manages multiple locations (Nodes)
      - The Owner is NOT a location - they operate FROM OUTSIDE the graph
      - Multiple Owners can compete for control of the same Nodes

    diagram: |
      ┌─────────────────────────────────────────────────────────────────────────┐
      │                        THE FRANCHISE MODEL                              │
      └─────────────────────────────────────────────────────────────────────────┘

          ┌──────────────────┐           ┌──────────────────┐
          │  Revolutionary   │           │      State       │
          │   Organization   │           │     (Agent)      │
          │     (Agent)      │           │                  │
          └────────┬─────────┘           └────────┬─────────┘
                   │                              │
                   │  manipulates via             │  manipulates via
                   │  GraphProtocol               │  GraphProtocol
                   │                              │
                   ▼                              ▼
      ┌─────────────────────────────────────────────────────────────────────────┐
      │                         GRAPH (Topology)                                │
      │                                                                         │
      │    ┌─────┐     SOLIDARITY      ┌─────┐     EXPLOITATION    ┌─────┐     │
      │    │ C001├────────────────────►│ C002├────────────────────►│ C003│     │
      │    │ P_w │                     │ C_w │                     │ C_b │     │
      │    └──┬──┘                     └─────┘                     └─────┘     │
      │       │                                                                 │
      │       │ TENANCY                                                         │
      │       ▼                                                                 │
      │    ┌─────┐         ADJACENCY           ┌─────┐                         │
      │    │ T001├────────────────────────────►│ T002│                         │
      │    │ Slum│                             │ Dock│                         │
      │    └─────┘                             └─────┘                         │
      │                                                                         │
      │    Nodes: SocialClass, Territory                                        │
      │    Edges: SOLIDARITY, EXPLOITATION, TENANCY, ADJACENCY, etc.           │
      └─────────────────────────────────────────────────────────────────────────┘

          AGENTS are EXTERNAL to the graph.
          AGENTS compete for control of graph NODES.
          AGENTS act via the GraphProtocol interface.

    implications:
      agent_not_node: |
        The Player (Revolutionary Organization) is NOT a node in the graph.
        It is an Agent with a "portfolio" of controlled nodes (cells, territories).
        The Agent's resources (war_chest, cadre) are stored separately from the graph.

      state_not_node: |
        The State is NOT a node - it is an Agent that manipulates Territories
        and applies repression to SocialClasses. The State's resources
        (legitimacy, repression_budget) are stored in StateFinance, not the graph.

      multiple_agents: |
        Multiple Agents can interact with the same graph:
        - Revolutionary Organization (Player)
        - State (AI opponent)
        - Rival Organizations (future: multiplayer or AI factions)

      ai_modeling: |
        AI opponents can have DIFFERENT VIEWS of the same graph (Fog of War).
        The Agent queries the graph through the interface and receives
        filtered/masked results based on their intel level.

      clear_separation: |
        Clear separation between:
        - "WHO acts" (Agents - external actors with resources and goals)
        - "WHAT is acted upon" (Graph - nodes and edges representing material reality)

# =============================================================================
# GRAPH STRUCTURE
# =============================================================================

graph_structure:
  type: "NetworkX DiGraph"

  node_types:
    social_class:
      marker: "_node_type: social_class"
      model: "babylon.models.entities.SocialClass"
      key_attributes:
        - "id: str (pattern C[0-9]{3})"
        - "role: SocialRole enum"
        - "wealth: Currency [0, ∞)"
        - "ideology: IdeologicalProfile"
        - "organization: Probability [0, 1]"
        - "repression_faced: Probability [0, 1]"

    territory:
      marker: "_node_type: territory"
      model: "babylon.models.entities.Territory"
      note: "Excluded from percolation analysis"

  edge_types:
    SOLIDARITY:
      direction: "Periphery → Core"
      weight: "solidarity_strength: Coefficient [0, 1]"
      purpose: "Consciousness transmission infrastructure"

    EXPLOITATION:
      direction: "Worker → Owner"
      weight: "value_flow: Currency"
      purpose: "Imperial rent extraction"

    WAGES:
      direction: "Bourgeoisie → Worker"
      weight: "value_flow: Currency"
      purpose: "Super-wage payments from imperial rent"

    REPRESSION:
      direction: "State → Class"
      weight: "tension: Intensity [0, 1]"
      purpose: "State violence accumulation"

    TRIBUTE:
      direction: "Comprador → Core Bourgeoisie"
      weight: "value_flow: Currency"
      purpose: "Periphery → Core via intermediary"

    CLIENT_STATE:
      direction: "Core → Peripheral State"
      weight: "value_flow: Currency, subsidy_cap: Currency"
      purpose: "Imperial subsidy for stability"

    COMPETITION:
      direction: "Bidirectional"
      weight: "tension: Intensity"
      purpose: "Market rivalry"

    TENANCY:
      direction: "SocialClass → Territory"
      purpose: "Occupancy relationship"

    ADJACENCY:
      direction: "Territory ↔ Territory"
      purpose: "Spatial connectivity"

  solidarity_subgraph:
    description: |
      For percolation analysis, extract undirected graph containing only:
      - social_class nodes (territories excluded)
      - SOLIDARITY edges above strength threshold
    function: "extract_solidarity_subgraph(G, min_strength)"
    returns: "nx.Graph[str] (undirected)"

# =============================================================================
# PERCOLATION METRICS
# =============================================================================

metrics:
  percolation_ratio:
    symbol: "p"
    formula: "L_max / N"
    range: "[0, 1]"
    description: "Fraction of network in giant component"
    interpretation:
      - "p < 0.1: Gaseous (atomized)"
      - "p >= 0.5: Liquid (condensed, vanguard formed)"

  num_components:
    description: "Number of disconnected subgraphs (solidarity cells)"
    interpretation: "Higher = more atomized"

  max_component_size:
    symbol: "L_max"
    description: "Size of largest connected component"
    interpretation: "The 'giant component' in percolation theory"

  potential_liquidity:
    threshold: 0.1
    description: "Count of SOLIDARITY edges with strength > 0.1"
    interpretation: "Sympathizer network (broad reach)"

  actual_liquidity:
    threshold: 0.5
    description: "Count of SOLIDARITY edges with strength > 0.5"
    interpretation: "Cadre network (committed activists)"

  cadre_density:
    formula: "actual_liquidity / max(1, potential_liquidity)"
    range: "[0, 1]"
    description: "Ratio of committed cadre to sympathizer network"
    interpretation:
      - "< 0.5: Mass movement with weak ties (liquid)"
      - ">= 0.5: Vanguard party with strong cadre discipline (solid)"
    note: "Distinguishes between broad movements and disciplined parties"

  brittleness:
    condition: "potential > actual * 2"
    description: "Movement is broad but lacks disciplined core"

# =============================================================================
# THRESHOLDS & CONSTANTS
# =============================================================================

thresholds:
  # Phase detection
  GASEOUS_THRESHOLD:
    value: 0.1
    file: "topology_monitor.py:48"
    description: "percolation_ratio below this = atomized movement"

  CONDENSATION_THRESHOLD:
    value: 0.5
    file: "topology_monitor.py:49"
    description: "percolation_ratio crossing this = phase shift detected"

  BRITTLE_MULTIPLIER:
    value: 2
    file: "topology_monitor.py:50"
    description: "potential > actual * this = brittle warning"

  # Liquidity classification
  POTENTIAL_MIN_STRENGTH:
    value: 0.1
    file: "topology_monitor.py:53"
    description: "Minimum solidarity_strength for sympathizer"

  ACTUAL_MIN_STRENGTH:
    value: 0.5
    file: "topology_monitor.py:54"
    description: "Minimum solidarity_strength for cadre"

  CADRE_DENSITY_THRESHOLD:
    value: 0.5
    file: "topology_monitor.py:_classify_phase"
    description: "Above this cadre_density, movement is 'solid' (disciplined vanguard)"

  # Resilience testing
  DEFAULT_REMOVAL_RATE:
    value: 0.2
    file: "topology_monitor.py:57"
    description: "Fraction of nodes removed in purge simulation"

  DEFAULT_SURVIVAL_THRESHOLD:
    value: 0.4
    file: "topology_monitor.py:58"
    description: "Required fraction of L_max to survive purge"

  # Consciousness dynamics
  LOSS_AVERSION_COEFFICIENT:
    value: 2.25
    file: "formulas.py:27"
    description: "Kahneman-Tversky loss aversion (kappa)"

  ACTIVATION_THRESHOLD:
    value: 0.3
    file: "GameDefines.solidarity.activation_threshold"
    description: "Minimum source consciousness for transmission"

# =============================================================================
# FORMULAS
# =============================================================================

formulas:
  consciousness_drift:
    location: "formulas.py:134-199"
    signature: |
      calculate_consciousness_drift(
        core_wages, value_produced, current_consciousness,
        sensitivity_k, decay_lambda, solidarity_pressure, wage_change
      ) -> float
    formula: "dΨ/dt = k(1 - W/V) - λΨ + B(ẇ, σ)"
    components:
      material_term: "k(1 - W/V)"
      decay_term: "λΨ"
      bifurcation_term: "B(ẇ, σ)"
    bifurcation_logic: |
      if wage_change < 0:
        agitation_energy = |wage_change| * 2.25
        if solidarity_pressure > 0:
          return +agitation_energy * min(1, solidarity_pressure)  # Revolution
        else:
          return -agitation_energy  # Fascism

  solidarity_transmission:
    location: "formulas.py:455-511"
    signature: |
      calculate_solidarity_transmission(
        source_consciousness, target_consciousness,
        solidarity_strength, activation_threshold
      ) -> float
    formula: "Δ = σ(Ψ_source - Ψ_target)"
    conditions:
      - "source_consciousness > activation_threshold (strictly >)"
      - "solidarity_strength > 0"
    note: "Transmission blocked if either condition fails (Fascist Bifurcation)"

  ideological_routing:
    location: "formulas.py:518-601"
    signature: |
      calculate_ideological_routing(
        wage_change, solidarity_pressure,
        current_class_consciousness, current_national_identity,
        current_agitation, agitation_decay
      ) -> tuple[float, float, float]
    returns: "(new_class_consciousness, new_national_identity, new_agitation)"
    routing_logic: |
      agitation_energy routes based on solidarity_factor:
      - High solidarity → class_consciousness increases
      - Low solidarity → national_identity increases (fascism)

# =============================================================================
# DATA MODELS
# =============================================================================

models:
  TopologySnapshot:
    location: "models/topology_metrics.py:23-67"
    type: "Pydantic BaseModel (frozen)"
    fields:
      tick: "int"
      num_components: "int"
      max_component_size: "int"
      total_nodes: "int"
      percolation_ratio: "Probability [0, 1]"
      potential_liquidity: "int"
      actual_liquidity: "int"
      cadre_density: "float [0, 1] (Sprint 3.3)"
      is_resilient: "bool | None"

  ResilienceResult:
    location: "models/topology_metrics.py:62-92"
    type: "Pydantic BaseModel (frozen)"
    fields:
      is_resilient: "bool"
      original_max_component: "int"
      post_purge_max_component: "int"
      removal_rate: "float"
      survival_threshold: "float"
      seed: "int | None"

  TopologyEvent:
    location: "models/events.py"
    type: "Pydantic BaseModel (frozen)"
    parent: "SimulationEvent"
    status: "IMPLEMENTED (Sprint 3.3)"
    fields:
      percolation_ratio: "Probability [0, 1]"
      num_components: "int"
    description: |
      Base class for topology-related events. Contains percolation metrics
      common to all topology events.

  PhaseTransitionEvent:
    location: "models/events.py"
    type: "Pydantic BaseModel (frozen)"
    parent: "TopologyEvent"
    status: "IMPLEMENTED (Sprint 3.3 - 4-phase model)"
    fields:
      event_type: "EventType.PHASE_TRANSITION"
      previous_state: "str (gaseous|transitional|liquid|solid)"
      new_state: "str (gaseous|transitional|liquid|solid)"
      largest_component_size: "int"
      cadre_density: "float [0, 1] (Sprint 3.3)"
      is_resilient: "bool | None"
    description: |
      Emitted when percolation_ratio or cadre_density crosses phase threshold boundaries.
      Represents the crystallization of atomized leftism into organized revolutionary
      force (liquid = mass movement, solid = vanguard party).

# =============================================================================
# PHASE STATES
# =============================================================================

phase_states:
  gaseous:
    threshold: "percolation_ratio < 0.1"
    description: "Atomized movement. No coordination capacity."
    political_meaning: |
      Individual cells operate in isolation. No giant component.
      State can eliminate nodes without cascade effects.
      Consciousness transmission blocked.

  transitional:
    threshold: "0.1 <= percolation_ratio < 0.5"
    description: "Emerging structure. Unstable coordination."
    political_meaning: |
      Some clusters forming but not yet a vanguard.
      Vulnerable to targeted disruption.
      Consciousness can propagate within clusters.

  liquid:
    threshold: "percolation_ratio >= 0.5 AND cadre_density < 0.5"
    description: "Mass movement formed. Broad but loosely organized."
    political_meaning: |
      Giant component exists (coordination possible).
      Movement of movements - many sympathizers, few committed cadre.
      Vulnerable to ideological drift and internal division.
      Historical example: Occupy Wall Street (2011).

  solid:
    threshold: "percolation_ratio >= 0.5 AND cadre_density >= 0.5"
    description: "Vanguard party crystallized. Disciplined cadre core."
    political_meaning: |
      Giant component AND strong ties throughout.
      Iron discipline - committed activists dominate network.
      Can survive repression and maintain ideological coherence.
      Historical example: Bolshevik Party (1917).

  classification_function:
    location: "engine/topology_monitor.py:_classify_phase()"
    signature: "_classify_phase(percolation_ratio: float, cadre_density: float = 0.0) -> str"
    returns: "'gaseous' | 'transitional' | 'liquid' | 'solid'"
    logic: |
      if percolation_ratio < GASEOUS_THRESHOLD:
          return "gaseous"
      if percolation_ratio < CONDENSATION_THRESHOLD:
          return "transitional"
      if cadre_density >= 0.5:
          return "solid"
      return "liquid"

# =============================================================================
# OBSERVER PATTERN
# =============================================================================

observer:
  class: "TopologyMonitor"
  location: "engine/topology_monitor.py:243-452"
  protocol: "SimulationObserver"
  status: "COMPLETE (Sprint 3.3)"

  lifecycle_hooks:
    on_simulation_start: "Initialize history, record initial snapshot, reset phase state"
    on_tick: "Record snapshot, detect phase transitions, emit PhaseTransitionEvent"
    on_simulation_end: "Log summary statistics"

  event_emission:
    status: "IMPLEMENTED (Sprint 3.3)"
    mechanism: |
      TopologyMonitor tracks _previous_phase and _pending_events internally.
      When percolation_ratio crosses a threshold boundary, a PhaseTransitionEvent
      is appended to _pending_events. The Simulation facade calls
      get_pending_events() after each tick, collecting events and injecting
      them into the next tick's WorldState via persistent_context['_observer_events'].
    methods:
      _classify_phase: "Determine current phase state from percolation_ratio"
      get_pending_events: "Return and clear pending events list"
    injection_point: "simulation_engine.py: step() reads persistent_context['_observer_events']"

  configuration:
    resilience_test_interval:
      type: "int"
      default: 5
      description: "Run resilience test every N ticks (0 = disabled)"
    resilience_removal_rate:
      type: "float"
      default: 0.2
      description: "Fraction of nodes to remove in test"

  narrative_states:
    gaseous:
      condition: "percolation_ratio < 0.1"
      message: "STATE: Gaseous. Movement is atomized."
    condensation_liquid:
      condition: "percolation_ratio crosses 0.5 AND cadre_density < 0.5"
      message: "PHASE SHIFT: Liquid state. Mass movement formed but lacks cadre discipline."
    condensation_solid:
      condition: "percolation_ratio >= 0.5 AND cadre_density >= 0.5"
      message: "PHASE SHIFT: Solid state. Vanguard Party has crystallized. Iron discipline achieved."
    liquid_to_solid:
      condition: "state transitions from liquid to solid (cadre_density crosses 0.5)"
      message: "CRYSTALLIZATION: Mass movement hardened into disciplined vanguard."
    brittle:
      condition: "potential > actual * 2"
      message: "WARNING: Movement is broad but brittle. Lacks cadre discipline."
    sword_of_damocles:
      condition: "is_resilient == False"
      message: "ALERT: Sword of Damocles active. A purge would destroy the movement."

# =============================================================================
# FILE REFERENCE
# =============================================================================

files:
  implementation:
    - path: "src/babylon/engine/topology_monitor.py"
      lines: 452
      purpose: "TopologyMonitor observer and helper functions"

    - path: "src/babylon/systems/formulas.py"
      lines: 707
      purpose: "Mathematical formulas (consciousness, bifurcation, survival)"

    - path: "src/babylon/models/topology_metrics.py"
      lines: 92
      purpose: "TopologySnapshot and ResilienceResult models"

    - path: "src/babylon/engine/systems/solidarity.py"
      lines: 199
      purpose: "SolidaritySystem consciousness transmission"

    - path: "src/babylon/models/world_state.py"
      lines: 283
      purpose: "WorldState.to_graph() and from_graph()"

  tests:
    - path: "tests/unit/topology/test_topology_monitor.py"
      tests: 34
      purpose: "Unit tests for percolation functions"

    - path: "tests/integration/test_topology_integration.py"
      tests: 21
      purpose: "Integration tests with Simulation lifecycle"

    - path: "tests/unit/topology/test_phase_transition.py"
      tests: 30
      purpose: "Phase transition event emission and injection (Sprint 3.3: 4-phase model)"

# =============================================================================
# COMMON QUERIES
# =============================================================================

common_queries:
  check_phase_state:
    pattern: |
      from babylon.engine.topology_monitor import TopologyMonitor
      monitor = TopologyMonitor()
      # After simulation runs...
      latest = monitor.history[-1]
      if latest.percolation_ratio < 0.1:
          print("Gaseous - Atomized")
      elif latest.percolation_ratio < 0.5:
          print("Transitional - Emerging")
      elif latest.cadre_density >= 0.5:
          print("Solid - Vanguard Party (iron discipline)")
      else:
          print("Liquid - Mass Movement (weak ties)")

  test_network_resilience:
    pattern: |
      from babylon.engine.topology_monitor import check_resilience
      graph = state.to_graph()
      result = check_resilience(graph, removal_rate=0.2, seed=42)
      if not result.is_resilient:
          print("Sword of Damocles: Network is fragile!")

  get_liquidity_metrics:
    pattern: |
      from babylon.engine.topology_monitor import calculate_liquidity
      graph = state.to_graph()
      potential, actual = calculate_liquidity(graph)
      if potential > actual * 2:
          print("Movement is broad but brittle")
